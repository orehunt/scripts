#!/bin/bash

## https://unix.stackexchange.com/a/407383/163931
fleep()
{
    [[ -n "${_snore_fd:-}" ]] || exec {_snore_fd}<> >(:)
    read ${1:+-t "$1"} -u $_snore_fd || :
}

##https://stackoverflow.com/a/8088167/2229761
define(){ IFS='\n' read -r -d '' ${1} || true; }

## reset counter $1 to $2 if has reached zero
step() {
    eval "counter_value=\$$1"
    if [ $counter_value = 0 ]; then
        eval "$1=$2"
        return 0
    else
        eval "$1=$((counter_value-1))"
        return 1
    fi
}

## increase $1 by $2 or 1 by def
incr() {
    eval "$1=$(($1+${2:-1}))"
}
## decrease $1 by $2 or 1 by def
decr() {
    eval "$1=$(($1-${2:-1}))"
}

## https://stackoverflow.com/a/11120761/2229761
hex2bin() {
    while [ $# -ne 0 ]
    do
        DecNum=$(printf "%d" $1)
        Binary=

        while [ $DecNum -ne 0 ]
        do
            Bit=$(expr $DecNum % 2)
            Binary=$Bit$Binary
            DecNum=$(expr $DecNum / 2)
        done

        echo -e ${Binary:-0}
        shift
        # Shifts command line arguments one step.Now $1 holds second argument
        unset Binary
    done
}

bin2hex() {
    printf '%x\n' "$((2#$1))"
}

## search the last occurrence of $2 and replace with $3  on string $1
replace_end() {
    local left=${1%${2}*}
    local right=${1/${left}}
    local replright=${right/${2}/${3}}
    echo "${left}${replright}"
}

## get path from name $1
get_path() {
    local whichis
    whichis=$(type $1) && echo ${whichis/#$1 is}
}

## RESOURCES MONITORING FUNCTIONS
## get statistics for process cpu usage monitoring
get_pid_stats(){
    pid="${pid:-$(pgrep php)}"
    [ -z "$pid" -o ! -a /proc/"$pid" ] && return 1
    read pupt < /proc/uptime;
    read stat < /proc/${pid}/stat && c=1 && for i in $stat; do
            case "$c" in
                14)
                    utime=$i
                    ;;
                15)
                    stime=$i
                    ;;
                16)
                    cutime=$i
                    ;;
                17)
                    cstime=$i
                    ;;
                22)
                    starttime=$i
                    break
                    ;;
            esac
            c=$((c+1));
        done
    uptimet=${pupt/.} && uptime=${uptimet/ *}
}

# calc an unit of cpu usage with interval $1
proc_usg_u(){
    get_pid_stats
    uptime1=$uptime
    proctime1=$((utime+stime+cutime+cstime))
    fleep $1
    get_pid_stats
    uptime2=$uptime
    proctime2=$((utime+stime+cutime+cstime))
    uptimediff=$((uptime2-uptime1))
    [ $uptimediff != 0 ] && \
    proc_perc_usg=$(((proctime2-proctime1)*100/uptimediff))
}

## cpu monitor $cpumon_pid $cpumon_span $cpumon_ival
cpumon() {
    export proc_usg
    pid=${cpumon_pid:-$(pgrep php)}
    ## timespan
    local span=${cpumon_span:-60}
    ## interval
    local ival=${cpumon_ival:-3}
    local iter=$((span/ival))
    local record=()
    while true; do
        # perc=$(top -n1 | grep php | grep -v grep | awk '{print gensub("%","","", $8)}')
        proc_usg_u 0.1 ## sets proc_perc_usg
        [ -z "$proc_perc_usg" ] && fleep $ival && continue
        record+=($proc_perc_usg)
        i=$((${#record[@]}-iter))
        [ $i -lt 0 ] && i=0
        record=(${record[@]:i})
        sum=0
        for p in "${record[@]}"; do
            sum=$((sum+p))
        done
        proc_usg=$((sum/${#record[@]}))
        echo ${proc_usg}
        # span=$((ival*${#record[@]}))s
        # echo "usage in $span is $proc_usg"
        fleep $ival
    done
}

## to be called with enable tracing
disable_tracing() {
    if [ -z "$dbg_tracing" ]; then
        [ ${-/x} != ${-} ] && ${dbg_tracing:=true} || ${dbg_tracing:=false}
        set +x
    else
        $dbg_tracing || set +x
        unset dbg_tracing
    fi
}

## to be called with disable tracing
enable_tracing() {
    if [ -z "$dbg_tracing" ]; then
        [ ${-/x} != ${-} ] && ${dbg_tracing:=true} || ${dbg_tracing:=false}
        set -x
    else
        $dbg_tracing && set -x
        unset dbg_tracing
    fi
}

## loadavg monitor loop or single call (currently single call for vars)
loadmon() {
    export cpu_avg_1 cpu_avg_5 cpu_avg_10
    # while true; do
    read avg < /proc/loadavg
    c=0
    for val in $avg; do
        case $c in
            0)
                cpu_avg_1=${val/.*}
                ;;
            1)
                cpu_avg_5=${val/.*}
                ;;
            2)
                cpu_avg_10=${val/.*}
                break
                ;;
        esac
        c=$((c+1))
        # done
        fleep 1
        # echo "$cpu_avg_1 $cpu_avg_5 $cpu_avg_10"
    done
}

## sets $job_n to the id of a coprocess named $1
id_coproc() {
    ## this implementation is broken because REMATCH order is not reliable
    # local reg="^(.*)coproc ${1}.*$"
    # jobs=$(jobs)
    # [[ "${jobs}" =~ $reg ]]
    # tmpstr=${BASH_REMATCH[1]/\]*}
    # job_n=${tmpstr/\[}
    # return $job_n
    local tmpstr
    while read j; do
        if [ "$j" != "${j/coproc ${1}}" ]; then
            tmpstr=${j/\[}
            job_n=${tmpstr/\]*}
        fi
    done < <(jobs -r)
}

## start coprocess named $1 with args $@..., will have last child process pid in fd 9
start_coproc() {
    # eval "coproc $1 { $* & exec 9<><(:) ; echo \$! >; wait; }"
    if [ "$1" = exec ]; then
        coproc_name="$2"
    else
        coproc_name="$1"
    fi

    eval "coproc $coproc_name { $*; }" 2>/dev/null
    # eval "read -ru \${$1[0]} ${coproc_name}_sub_pid"
}

## stop coprocess named $1 with signal $2
stop_coproc() {
    id_coproc "$1" && eval "kill -${2:-15} %$job_n"
    # eval "kill -$2 \${${1}_PID}"
    # eval "kill -$2 \${${1}_sub_pid}"
    # eval "pkill -P \${${1}_PID}"
}

## wait for a coprocess named $1 to start
wait_coproc() {
    while :; do
        id_coproc "$1"
        ! eval "kill -0 %$job_n" || break
        fleep 1
    done
}

## flush the output of a coprocess $1 returning the last line read with $2
read_coproc() {
    eval "fd=\${$1[0]}"
    while read -t 0.1 -ru $fd l; do
        [ -z "$l" ] && break
        eval "$2=$l"
    done
}

## try to get a string before $3 and after $1 from $2
before_after() {
    string="$2"
    before="${string#*$1}"
    after="${before/$3*}"
}

## queries ipinfo and gets the current ip and country/region
parse_ip() {
    ipquery=$(wget -qO- ipinfo.io)
    [ -z "$ipquery" ] && echo "failed querying ipinfo" && return 1
    ## remember to quote ipquery cuz json has newlines
    before_after 'ip": "' "$ipquery" '"'
    ip=$after
    [ -z "$ip" ] && echo "failed parsing ipinfo data ip" && return 1
    before_after 'country": ' "$ipquery" ','
    country=$after
    [ -z "$country" ] && echo "failed parsing ipinfo data country" && return 1
    ## get region
    while read l; do
        if [ "${l}" != "${l/\": {}" ]; then
            before_after '"' "$l" '"'
            lastregion=$after
        elif [ "${l}" != "${l/${country,,}}" ]; then
            region=$lastregion
            break
        fi
    done < cfg/geoip.json
}
