#!/bin/bash

## gnu grep and sed required
[ "$FUNCTIONS" = SOURCED ] || . ./functions

# if [ -z "$2" ]; then
#     echo "USAGE: pausd [executable] [config]"
#     exit 1
# fi

## number of accepted shares before pause
shares=${PAUSD_SHARES:-1}
## proxy
export LD_LIBRARY_PATH=pl/lib ## for proxychains lib

## ulimits
for ul in $(ulimit -a | sed -r 's/.*\((.*, )?(.*)\).*/\2/'); do
    ulimit $ul unlimited &>/dev/null; done
ulimit -c 0 &>/dev/null

## override
if [ -n "$PAUSD_OVERRIDE" ]; then
    threads=${PAUSD_THREADS:-1}
    ver=${PAUSD_VER:-2}
    ARGS_OVERRIDE=" -v $ver -t $threads "
else
    unset ARGS_OVERRIDE
fi

## tune the load on the host (TODO normalize rate so it is friendlier)
## rate=100 means half the available time is used (sleep half the time)
## rate=200 means 2/3 of the available time (sleep 1/3)
## rate=50 means 1/3 of the avaialble time (sleep 2/3)
## rate=1000 means 90/100 of the avaialble time (sleep 1/10)
rate=${PAUSD_RATE:-40}

## start the object
function objectd() {
    export -n $(export -p) 2>/dev/null
    exec "$PAUSD_ARGS" \
        $ARGS_OVERRIDE
}

## tells pausd when shares are enough
function pinger() {
    # clean_env forwarded_lines ping_last_state SWITCH_STATE pause_if_overload loadmon adjust_shares shares
    accepted=0
    local ok
    while read -ru ${forwarded_lines} string; do
        ## update state
        read_fd ${ping_last_state} SWITCH_STATE
        pause_if_overload
        if [ "$SWITCH_STATE" = SLEEP ] && ## the fd of the state is only supposed to change state between wakeup/sleep
               [ "${string/accepted}" != "${string}" ]; then
            accepted=$((accepted + 1))
            # echo "accepted shares: $accepted, max shares: $shares" >> /tmp/pausd_pinger
            ## adjust shares
            # read_fd ${ping_rate} rate ## update rate calculated by pauser
            loadmon ## update cpu load
            adjust_shares
            if [ $accepted -ge $shares ]; then
                ## message pauser
                accepted=0
                echo lock
                read ## wait for the pingback
            fi
        fi
    done
}

## adjust rate based on load
adjust_rate() {
    ## skip if not different
    [ "$prev_rate" = "$rate" ] && return
    ## store rate
    prev_rate=$rate
    ## calc the adjustement
    local adj
    adj=$((rate/3))
    [ $adj = 0 ] && adj=$((rate%3))

    if ! $load_check_func; then
        newrate=$((rate-adj))
        [ $rate -ge 50 -a $newrate -ge 50 ] && rate=$newrate || rate=50
    else
        newrate=$((rate+adj))
        [ $rate -le 500 -a $newrate -le 500 ] && rate=$newrate || rate=500
    fi
    # echo "rate adjusted to $rate" >> /tmp/pausd_rate
    ## send new rate to pinger
    # echo $rate >&${ping_rate}
}

## adjust shares based on load
adjust_shares() {
    ## calc the adjustement
    local adj
    adj=$((shares/3))
    [ $adj = 0 ] && adj=$((shares%3))

    ## 1 shares should take average of 5-15s, so max should be well within 5 minutes
    if ! $load_check_func; then
        newshares=$((shares-adj))
        [ $shares -ge 1 -a $newshares -gt 1 ] && shares=$newshares || shares=1
    else
        newshares=$((shares+adj))
        [ $shares -le 30 -a $newshares -lt 30 ] && shares=$newshares || shares=30
    fi
    # echo "shares adjusted to $shares" >> /tmp/pausd_shares
}

## wrapper for resume command
resume(){
    echo r >&${objectd[1]} ## resume
}

## wrapper for pause command
pause() {
    echo p >&${objectd[1]} ## resume
}

## wraper for the lock
waitlock() {
    while ! lock; do
        fleep 0.5
    done
}

## pauser
pauser() {
    while kill -0 $objectd_PID; do ## while the object is running
        pause_if_overload
        ## read from log file
        start=$SECONDS
        resume ## resume the object
        unlock ## unlock pausd state

        read -ru ${pinger[0]} lock ## wait for a lock from the pinger
        stop=$SECONDS
        echo ok >&${pinger[1]}
        ## lock the pausd lock to prevent switcher from switching
        waitlock

        ## pause the object
        pause

        ## wait the specified amount, adjust rate for load
        # read_fd ${paus_proc_usg} PROC_USG ## proc usg
        ## skew proc_usg to match pausd_rate (if rate is 100->pausing half the time->real usg is 2x)
        # PROC_USG=$(((PROC_USG*2*rate/200)*2))
        loadmon ## update cpu load
        adjust_rate
        wait=$(( (stop - start) * 100 / rate ))
        # echo "wait: $wait, rate: $rate" >> /tmp/pausd_pauser
        fleep $wait
    done
}

## pause if overloaded, MAX_LOAD should be in CORES*100
pause_if_overload() {
    if [ -n "$MAX_LOAD" ]; then
        loadmon_prc
        if [ $cpu_avg_prc_1 -ge $MAX_LOAD ]; then ## greater or equal in case maxed
            waitlock && pause
            while [ $cpu_avg_prc_1 -ge $MAX_LOAD ]; do
                loadmon_prc
                fleep 1
            done
            resume && unlock
        fi
    fi
}

## limiter
limiter() {
    varToFile CLM_BIN clm && chmod +x clm
    (fleep 3; rm -f clm) &>/dev/null &
    export -n $(export -p) 2>/dev/null
    exec clm -l${CLIMIT} -m -p $objectd_PID
}

# pid=$! ## for non tmux
# pid=$((pid-1)) ## for non zsh
# [ -z "$pid" ] && echo "process not started" && exit 1
function pausd() {
    # trap 'trap - SIGTERM SIGINT EXIT && for cp in objectd pinger pauser; do stop_coproc $cp; done' SIGTERM SIGINT EXIT
    ## make sure no lingering coprocs are left
    for cp in objectd pinger pauser limiter locker; do
        stop_coproc $cp 2>/dev/null
        clear
    done
    clear_fds $ping $ping_last_state $ping_proc_usg $is_switching ## clear file descriptors, exclude...

    if [ -n "$MAX_LOAD" ]; then ## functions defined in switcher
        load_check_func="load_check_prc_fixed 5 $MAX_LOAD" ## use 5 minutes to vary the rates a little
    else
        load_check_func="load_check 1"
    fi

    ## start the object
    start_coproc objectd
    ## start optional cpu limiter after the object to get its pid
    if [ -n "$CLIMIT" ]; then
        UNSET_COPROC_VARS="OBJ_BIN"
        start_coproc limiter
    fi
    ## start the pinger
    newfd forwarded_lines
    newfd ping_last_state
    # newfd ping_proc_usg
    # newfd ping_rate
    UNSET_COPROC_VARS="OBJ_BIN CLM_BIN"
    start_coproc pinger
    ## the locker prevents pausing during switching
    UNSET_COPROC_VARS="OBJ_BIN CLM_BIN"
    start_coproc locker
    ## start pausing
    # newfd paus_proc_usg
    UNSET_COPROC_VARS="OBJ_BIN CLM_BIN"
    start_coproc pauser
    # exit 1
}

## start the pausd coprocess
function start_pausd() {
    kill -9 ${PAUSD_DAEMON_NAME}_PID 2>/dev/null
    eval "coproc ${PAUSD_DAEMON_NAME} { ${PAUSD_DAEMON_NAME}; }"
}

## considerations
## $wait does not need any rand mangling because the accepted notifications are variable enough
