#!/bin/bash

## gnu grep and sed required

if [ -z "$2" ]; then
    echo "USAGE: pausd [executable] [config]"
    exit 1
fi

## number of accepted shares before pause
shares=${PAUSD_SHARES:-1}
## process config
threads=${PAUSD_THREADS:-1}
ver=${PAUSD_VER:-2}
[ $threads = 1 ] && ver=2 ## on one process av2 is better
lock=".${PAUSD_DAEMON}.lock"

## override
if [ -n "$PAUSD_OVERRIDE" ]; then
    ARGS_OVERRIDE=" -v $ver -t $threads "
else
    unset ARGS_OVERRIDE
fi

## tune the load on the host (TODO normalize rate so it is friendlier)
## rate=100 means half the available time is used (sleep half the time)
## rate=200 means 2/3 of the available time (sleep 1/3)
## rate=50 means 1/3 of the avaialble time (sleep 2/3)
## rate=1000 means 90/100 of the avaialble time (sleep 1/10)
rate=${PAUSD_RATE:-40}

## start the process
## write to /tmp when shares are accepted
export SHELL=$(/usr/bin/which bash)
tmux split-window -dv \
     "accepted=0; $1 -c $2 \
             $ARGS_OVERRIDE \
             | while read string; do
                         if [ -n \"\$(echo \"\$string\" | grep -i accepted)\" ]; then
                            accepted=\$((accepted + 1))
                            if [ \$accepted -ge $shares ]; then
                               accepted=0
                               while [ -e /tmp/${lock} ]; do
                                     sleep 1
                               done
                               touch /tmp/${lock};
                            fi
                         fi
                done"

# pid=$! ## for non tmux
# pid=$((pid-1)) ## for non zsh
# [ -z "$pid" ] && echo "process not started" && exit 1

# while [ -n $(pgrep $pid) ]; do ## for non tmux
while [ -n "$(tmux list-sessions | grep -i ${PAUSD_DAEMON})" ]; do
    ## read from log file
    start=$(date +%s)
    # kill -CONT $pid ## for non tmux
    tmux send-keys -t .1 r
    while true; do
        if [ -e /tmp/${lock} ]; then
            stop=$(date +%s)
            # kill -STOP $pid ## for non tmux
            tmux send-keys -t .1 p
            wait=$(( (stop - start) * 100 / rate ))
            rm -f /tmp/${lock}
            sleep $wait
            break
        else
            sleep 1
        fi
    done
done

exit 1

## considerations
## $wait does not need any rand mangling because the accepted notifications are variable enough
