#!/bin/bash

## gnu grep and sed required
[ "$FUNCTIONS" = SOURCED ] || . ./functions

# if [ -z "$2" ]; then
#     echo "USAGE: pausd [executable] [config]"
#     exit 1
# fi

## proxy
export LD_LIBRARY_PATH=pl/lib ## for proxychains lib

export PROC_USG ## stores the latest recorded proc usage of the object
export MAX_USG=${MAX_USG:-${MAX_LOAD:-$((CORES*100))}} MAX_USG_WINDOW=${MAX_USG_WINDOW:-$((CORES*10))}
export WORK_TIME=300 WORK_DURATION=0 CSLEEP=${CSLEEP:-0}

## ulimits
lflags="-c -d -e -f -i -l -m -n -p -q -r -s -t -u -v -x "
prevIFS=$IFS
for ul in $lflags; do
    ulimit $ul unlimited &>/dev/null; done
ulimit -c 0 &>/dev/null
IFS=$prevIFS

## start the object
function objectd() {
    dex_env
    log "objectd: execing with $ARGS"
    exec "$ARGS" 2>&1
}

## wrapper for resume command
resume(){
    echofd ${objectd[1]} r ## resume
}

## wrapper for pause command
pause() {
    echofd ${objectd[1]} p ## resume
}

## wraper for the lock
waitlock() {
    while ! lock; do
        fleep 5
    done

}

## true if load in 1 5 or 10 minutes (from $1) is lower than $CORES minus the current threads
load_check() {
    period=${1:-${cpu_avg_period}}
    eval "cpu_avg=\${cpu_avg_${period}}"
    [ $cpu_avg -lt $((CORES-cThr)) ] ## return code should match this statement
}

load_check_prc() {
    period=${1:-${cpu_avg_period}}
    eval "cpu_avg=\${cpu_avg_prc_${period}}"
    [ $cpu_avg -lt $(((CORES-cThr)*100)) ] ## return code should match this statement
}

## true if load in 1 5 or 10 minutes (from $1) is lower than $2
load_check_fixed() {
    period=${1:-${cpu_avg_period}}
    eval "cpu_avg=\${cpu_avg_${period}}"
    [ $cpu_avg -lt $2 ] ## return code should match this statement
}

load_check_prc_fixed() {
    period=${1:-${cpu_avg_period}}
    eval "cpu_avg=\${cpu_avg_prc_${period}}"
    [ $cpu_avg -lt $2 ] ## return code should match this statement
}

## true if usage diff is < ${1}% (20%) from current max threads usage
## if true it means the process has enough resources available, otherwise the number of threads
## should be lowered
usg_check() {
    [ $PROC_USG -gt $((cThr*100-${1:-20})) ]
}

## true if total host cpu usage is < $1 (1-100)
## usage calculate average in the last three seconds each second
host_usg_check() {
    usgmon_prc 1 3
    [ $cpu_avg_prc_1 -lt ${1:-100} ]
}

cpu_check() {
    usg_check && load_check $1
}



tune_sleep_to_usg(){
    PREV_SLEEP=$CSLEEP
    [ -n "$NO_SLEEP_TUNE" ] && return
    [ $CSLEEP -lt 1 ] && CSLEEP=10
    usgmon_prc 1 5
    log "balancer: MAX_USG: $MAX_USG, PROC_USG: $PROC_USG"
    USG_WINDOW=$((MAX_USG-PROC_USG))
    log "balancer: tuning sleep USG_WINDOW : $USG_WINDOW"
    if [ $((USG_WINDOW-MAX_USG_WINDOW)) -gt 5 ]; then
        CSLEEP=$((CSLEEP-CSLEEP/8))
        log "tune_sleep: decreasing sleep to $CSLEEP"
    # tune to sleep to target a 300s work window
    elif [ $WORK_DURATION -lt $WORK_TIME ] ||
             [ $cpu_avg_usg -ge $MAX_USG ]; then
        CSLEEP=$((CSLEEP/4+CSLEEP))
        log "tune_sleep: increasing sleep to $CSLEEP"
    fi
    log "balancer: prev_sleep, new_sleep: $PREV_SLEEP , $CSLEEP"
    if [ $PREV_SLEEP != $CSLEEP ]; then
        change_config sleep $CSLEEP
        dump_config
    fi
}

## pauser
balancer() {
    log "starting balancer loop"
    export LAST_OVERLOAD=$SECONDS WORK_DURATION=$WORK_TIME
    while kill -0 $objectd_PID; do ## while the object is running
        log "looping pauser"
        pause_if_overload

        log "pauser: received balancer lock, pausing"
        ## lock the pausd lock to prevent switcher from switching

        loadmon ## update cpu load
        log "reading coproc cpumon ${cpumon_PID}"
        read_coproc cpumon PROC_USG
        tune_sleep_to_usg

        pause_if_overload
        fleep 5
    done
    unlock ## unlock in case something is wrong to prevent stalls
    fleep 10 ## sleep to prevent wait_coproc to loop indefinitely
    log "error: pauser stopped because objectd is not running..."
}

overload(){
    loadmon_prc
    log "cpu_avg_prc_1: $cpu_avg_prc_1 >= $MAX_LOAD"
    [ $cpu_avg_prc_1 -ge $MAX_LOAD ]
}
## pause if overloaded, MAX_LOAD should be in CORES*100
pause_if_overload() {
    local pausetime
    if overload; then ## greater or equal in case maxed
        WORK_DURATION=$((SECONDS-LAST_OVERLOAD))
        log "pifo: overload duration $WORK_DURATION"
        LAST_OVERLOAD=$SECONDS
        log "pifo: waitlock and pause"
        waitlock ; pause
        pausetime=$SECONDS
        log "pifo: sleeping until within load"
        while overload; do
            log "pifo: loadmon within slep"
            log "pifo: sleep"
            fleep 1
        done
        log "pifo: resume"
        resume
        log "pifo: unlock"
        unlock
    fi
    resume
    log "pifo: done"
}


# pid=$! ## for non tmux
# pid=$((pid-1)) ## for non zsh
# [ -z "$pid" ] && echo "process not started" && exit 1
function pausd() {
    # trap 'trap - SIGTERM SIGINT EXIT && for cp in objectd balancer pauser; do stop_coproc $cp; done' SIGTERM SIGINT EXIT
    ## make sure no lingering coprocs are left
    for cp in objectd balancer pauser locker; do
        stop_coproc $cp 2>/dev/null
    done
    clear
    clear_fds $ping $ping_last_state $ping_proc_usg $forwarded_lines 2>/dev/null ## clear file descriptors, exclude...

    # set -x
    ## start the object
    start_coproc objectd

    ## after start adhocs
    if type -p "${provider}_start" &>/dev/null; then
        log "thirdparty_start - provider: $provider"
        eval "${provider}_start"
    fi

    ## the locker prevents pausing during switching
    # UNSET_COPROC_VARS="OBJ_BIN CLM_BIN"
    start_coproc locker
    ## cpumon
    # UNSET_COPROC_VARS="OBJ_BIN CLM_BIN"
    log 'miner: starting cpumon'
    start_coproc cpumon ${objectd_PID} ${cpumon_span} ${cpumon_ival} 2>/dev/null
    # UNSET_COPROC_VARS="OBJ_BIN CLM_BIN"
    start_coproc balancer
    # exit 1
}

## start the pausd coprocess
function start_pausd() {
    kill -9 ${DAEMON_NAME}_PID 2>/dev/null
    eval "coproc ${DAEMON_NAME} { ${DAEMON_NAME}; }"
}

## considerations
## $wait does not need any rand mangling because the accepted notifications are variable enough
