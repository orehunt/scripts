#!/bin/bash -i

## gnu grep and sed required

if [ -z "$2" ]; then
    echo "USAGE: pausd [executable] [config]"
    exit 1
fi

## number of accepted shares before pause
shares=${PAUSD_SHARES:-1}
## process config
threads=${PAUSD_THREADS:-1}
ver=${PAUSD_VER:-2}
[ $threads = 1 ] && ver=2 ## on one process av2 is better
## tmux session name
ssn=${PAUSD_SESSION_NAME:-daemon}

## tune the load on the host (TODO normalize rate so it is friendlier)
## rate=100 means half the available time is used (sleep half the time)
## rate=200 means 2/3 of the available time (sleep 1/3)
## rate=50 means 1/3 of the avaialble time (sleep 2/3)
## rate=1000 means 90/100 of the avaialble time (sleep 1/10)
rate=${PAUSD_RATE:-40}

## start the process
## write to /tmp when shares are accepted
export SHELL=/bin/bash
tmux new-session -d -s $ssn \
     "accepted=0; $1 -c $2 \
             -v $ver \
             -t $threads | while read string; do
                         if [ -n \"\$(echo \"\$string\" | grep -i accepted)\" ]; then
                            accepted=\$((accepted + 1))
                            if [ \$accepted -ge $shares ]; then
                               accepted=0
                               while [ -e /tmp/.${ssn}_lock ]; do
                                     sleep 1
                               done
                               touch /tmp/.${ssn}_lock;
                            fi
                         fi
                done"

# pid=$! ## for non tmux
# pid=$((pid-1)) ## for non zsh
# [ -z "$pid" ] && echo "process not started" && exit 1

# while [ -n $(pgrep $pid) ]; do ## for non tmux
while [ -n "$(tmux list-sessions | grep -i $ssn)" ]; do
    ## read from log file
    start=$(date +%s)
    # kill -CONT $pid ## for non tmux
    tmux send-keys -t $ssn r
    while true; do
        if [ -e /tmp/.${ssn}_lock ]; then
            stop=$(date +%s)
            # kill -STOP $pid ## for non tmux
            tmux send-keys -t $ssn p
            wait=$(( (stop - start) * 100 / rate ))
            rm -f /tmp/.${ssn}_lock
            sleep $wait
            break
        else
            sleep 1
        fi
    done
done

exit 1

## considerations
## $wait does not need any rand mangling because the accepted notifications are variable enough
