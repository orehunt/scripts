#!/bin/bash

## gnu grep and sed required
[ "$FUNCTIONS" = SOURCED ] || . ./functions

# if [ -z "$2" ]; then
#     echo "USAGE: pausd [executable] [config]"
#     exit 1
# fi

## number of accepted shares before pause
shares=${PAUSD_SHARES:-1}
## proxy
export LD_LIBRARY_PATH=pl/lib ## for proxychains lib

## ulimits
for ul in $(ulimit -a | sed -r 's/.*\((.*, )?(.*)\).*/\2/'); do
    ulimit $ul unlimited &>/dev/null; done

## override
if [ -n "$PAUSD_OVERRIDE" ]; then
    threads=${PAUSD_THREADS:-1}
    ver=${PAUSD_VER:-2}
    ARGS_OVERRIDE=" -v $ver -t $threads "
else
    unset ARGS_OVERRIDE
fi

## tune the load on the host (TODO normalize rate so it is friendlier)
## rate=100 means half the available time is used (sleep half the time)
## rate=200 means 2/3 of the available time (sleep 1/3)
## rate=50 means 1/3 of the avaialble time (sleep 2/3)
## rate=1000 means 90/100 of the avaialble time (sleep 1/10)
rate=${PAUSD_RATE:-40}

## start the object
function objectd() {
    export -n $(export -p) 2>/dev/null
    exec "$PAUSD_ARGS" \
        $ARGS_OVERRIDE
}

## tells pausd when shares are enough
function pinger() {
    accepted=0
    while read string; do
        ## update state
        read_fd ${ping_last_state} SWITCH_STATE
        if [ "$SWITCH_STATE" = SLEEP ] && ## the fd of the state is only supposed to change state between wakeup/sleep
               [ "${string/accepted}" != "${string}" ]; then
            accepted=$((accepted + 1))
            # echo "accepted shares: $accepted, max shares: $shares" >> /tmp/pausd_pinger
            ## adjust shares
            read_fd ${ping_rate} rate ## update rate calculated by pauser
            loadmon ## update cpu load
            adjust_shares
            if [ $accepted -ge $shares ]; then
                ## message pauser
                accepted=0
                echo lock
                read -ru ${ping} ## wait for the pingback

                            fi
        fi
    done
}

## adjust rate based on load
adjust_rate() {
    ## skip if not different
    [ "$prev_rate" = "$rate" ] && return
    ## store rate
    prev_rate=$rate
    ## calc the adjustement
    local adj
    adj=$((rate/3))
    [ $adj = 0 ] && adj=$((rate%3))

    if ! load_check 1; then
        newrate=$((rate-adj))
        [ $rate -ge 50 -a $newrate -ge 50 ] && rate=$newrate || rate=50
    else
        newrate=$((rate+adj))
        [ $rate -le 500 -a $newrate -le 500 ] && rate=$newrate || rate=500
    fi
    # echo "rate adjusted to $rate" >> /tmp/pausd_rate
    ## send new rate to pinger
    # echo $rate >&${ping_rate}
}

## adjust shares based on load
adjust_shares() {
    ## calc the adjustement
    local adj
    adj=$((shares/3))
    [ $adj = 0 ] && adj=$((shares%3))

    ## 1 shares should take average of 5-15s, so max should be well within 5 minutes
    if ! load_check 1; then
        newshares=$((shares-adj))
        [ $shares -ge 1 -a $newshares -gt 1 ] && shares=$newshares || shares=1
    else
        newshares=$((shares+adj))
        [ $shares -le 30 -a $newshares -lt 30 ] && shares=$newshares || shares=30
    fi
    # echo "shares adjusted to $shares" >> /tmp/pausd_shares
}

## pauser
pauser() {
    while kill -0 $objectd_PID; do ## while the object is running
        ## read from log file
        start=$SECONDS
        echo r >&${objectd[1]} ## resume
        unlock ## unlock pausd state

        read -ru ${pinger[0]} lock ## wait for a lock from the pinger
        stop=$SECONDS
        echo ok >&${ping}
        ## lock the pausd lock to prevent switcher from switching
        while ! lock; do
            fleep 0.5
        done

        ## pause the object
        echo p >&${objectd[1]}
        ## wait the specified amount, adjust rate for load
        # read_fd ${paus_proc_usg} PROC_USG ## proc usg
        ## skew proc_usg to match pausd_rate (if rate is 100->pausing half the time->real usg is 2x)
        # PROC_USG=$(((PROC_USG*2*rate/200)*2))
        loadmon ## update cpu load
        adjust_rate
        wait=$(( (stop - start) * 100 / rate ))
        # echo "wait: $wait, rate: $rate" >> /tmp/pausd_pauser
        fleep $wait
    done
}

## limiter
limiter() {
    while kill -0 $objectd_PID; do
        exec clm -l${CLIMIT} -m -p $objectd_PID
    done
}

# pid=$! ## for non tmux
# pid=$((pid-1)) ## for non zsh
# [ -z "$pid" ] && echo "process not started" && exit 1
function pausd() {
    # trap 'trap - SIGTERM SIGINT EXIT && for cp in objectd pinger pauser; do stop_coproc $cp; done' SIGTERM SIGINT EXIT
    ## make sure no lingering coprocs are left
    for cp in objectd pinger pauser limiter locker; do
        stop_coproc $cp 2>/dev/null
        clear
    done
    clear_fds $ping $ping_last_state $ping_proc_usg $is_switching ## clear file descriptors, exclude...

    ## start optional cpu limiter before the object
    [ -n "$CLIMIT" ] &&
        start_coproc limiter
    ## start the object
    start_coproc objectd
    ## start the pinger
    exec {ping}<> <(:)
    exec {ping_last_state}<> <(:)
    # exec {ping_proc_usg}<> <(:)
    # exec {ping_rate}<> <(:)
    start_coproc pinger
    ## the locker prevents pausing during switching
    start_coproc locker
    ## start pausing
    # exec {paus_proc_usg}<> <(:)
    start_coproc pauser
    # exit 1
}

## start the pausd coprocess
function start_pausd() {
    kill -9 ${PAUSD_DAEMON_NAME}_PID 2>/dev/null
    eval "coproc ${PAUSD_DAEMON_NAME} { ${PAUSD_DAEMON_NAME}; }"
}

## considerations
## $wait does not need any rand mangling because the accepted notifications are variable enough
